## 궁금증

저는 백엔드 개발자이지만, 트랜잭션에 대해서 피상적으로만 알고 있습니다.

부끄럽지만 아직 쿼리를 짤 때 트랜젝션을 제대로 짜서 실행해 본 적이 없습니다. 
하지만 현업에 들어오니, 트랜잭션, 롤백 등에 대한 개념을 잘 알고 있어야 개발할 때 실수를 줄이고, 실수에 대한 대응을 잘 할수 있겠다는 생각이 들었습니다.

그래서, DB 사용을 좀 더 잘하는 개발자가 될 수 있도록, 이 기회를 통해 DB에서의 트랜잭션에 대해서 한번 정리해 보려고 합니다.

</br>

## 트랜잭션의 전형적인 구조

DB 트랜잭션의 전형적인 구조는 다음과 같습니다. 

```sql
BEGIN;

-- 여러 작업 수행
UPDATE ...
INSERT ...
DELETE ...

-- 모든 작업이 성공하면
COMMIT;

-- 중간에 문제가 생기면
ROLLBACK;
```

기본적인 개념만 설명해 보자면, 아래와 같습니다.

| 키워드 | 의미 |
| --- | --- |
| BEGIN | 트랜잭션을 시작한다 (이후의 작업은 묶어서 처리됨) |
| COMMIT | 지금까지의 작업을 확정한다. |
| ROLLBACK | 지금까지의 작업을 취소한다. |

각 키워드들과 트랜잭션의 세부적인 특성에 대해서는, 아래에 하나하나 자세히 설명하며 공부해 보겠습니다.

</br>

## `BEGIN` 키워드

시작은 이전 커밋에서 제가 궁금증이 생겼었던 `BEGIN` 키워드 부터 시작하겠습니다.
놀랍게도 이 개발자는 `BEGIN` 키워드를 사용해 본 적이 없어서, 어떠한 역할을 하는지를 제대로 모르고 있었습니다.

나중에 제가 유명해졌을때(?) 이 글이 파묘당해서 사람들에게 충격을 주지 않을까... 하는 상상을 한번 해보며 일단 지금은 저를 아무도 모르니 그냥 공부하는 기분으로 시작하겠습니다.

### `BEGIN`의 의미

SQL에서 `BEGIN` 키워드는 트랜잭션(Transaction)을 시작한다는 의미입니다.

```sql
BEGIN;
```

-> 트랜잭션 블록 시작
이후에 수행하는 작업들은 **묶음(하나의 트랜잭션)** 으로 처리됩니다.

### `BEGIN`이 필요한 이유

#### 1. 여러 작업을 하나의 단위로 묶기 위해
- 위에도 말했듯이, 하나의 트랜잭션으로 설정을 하면 중간에 한 작업이 실패하면 전체 취소할 수 있도록 합니다.
- 이는 DB 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 ACID 중 **Atomicity, 즉 원자성을 지키기 위해서입니다.**

#### 2. 자동 커밋(autocommit)을 끄기 위해
- 대부분의 DB는 기본적으로 한 줄을 실행하면 자동으로 커밋이 된다고 합니다. 이렇게 되면 중간 실패 시 롤백을 할 수 없게 됩니다.
- `BEGIN`을 사용하면 이런 자동 커밋 기능을 해제할 수 있습니다.

### `BEGIN`이 트랜잭션에 포함시키는 것.

이쯤 되면, BEGIN 키워드로 묶이는 것들에는 어떤 구문들이 있는지 궁금해 질 수 밖에 없습니다. ~안궁금하셨다구요? 그래도 계속 읽어주세요~

| 구문 예시 | 포함 여부 | 설명 |
| --- | --- | --- |
| `INSERT`, `UPDATE`, `DELETE` | O | 데이터 변경 작업들 |
| `SELECT ... FOR UPDATE` | O | 동시성 제어용 SELECT |
| `CREATE TABLE`, `DROP TABLE` | X (MySQL 기준) | 대부분 트랜잭션과 별개로 처리됨 (DDL은 예외) |

- *참고로, DDL은 DBMS마다 다르며, PostgreSQL은 일부 DDL도 트랜잭션 내에서 사용 가능하다고 합니다.

### DBMS별 트랜잭션 관련 키워드 차이

| DBMS | 트랜잭션 시작 키워드 | 비고 |
| --- | --- | --- |
| MySQL | `START TRANSACTION` 또는 `BEGIN` | 동일 기능 |
| PostgreSQL | `BEGIN` | 표준 |
| Oracle | 트랜잭션은 DML 실행 시 자동 시작 | `BEGIN` 키워드 없음 (PL/SQL에서는 블록 시작용으로 사용) |
| SQL Server | `BEGIN TRANSACTION` | 명확하게 명시해야 함 |

### `PL/SQL` / `T-SQL` / 프로시저 / 블록 정의

`BEGIN` 키워드에 대한 설명에서 다음과 같은 문장이 나왔습니다.

> 프로시저 안에서 `BEGIN`은 블록 정의로 사용되기도 함(주의: PL/SQL, T-SQL에서는 다르게 해석됨)

한 문장에 모르는 단어들이 4개나 나와서 정리하고 가려고 합니다.

#### 1. PL/SQL

> Procedural Language / SQL의 약어로, Oracle에서 사용하는 절차형(논리 흐름이 있는) SQL 언어입니다.
- 일반적인 SQL은 `SELECT`, `INSERT` 같은 정적인 명령 위주이지만,
- PL/SQL은 `IF`, `FOR`, `LOOP`, `변수`, `예외처리`, `BEGIN~END` 블록 등을 포함하는 프로그래밍 언어 스타일입니다.
- (주의) Oracle에서만 사용됩니다.

사용 예시
```sql
DECLARE
  v_name VARCHAR2(50);
BEGIN
  SELECT name INTO v_name FROM users WHERE id = 1;
  DBMS_OUTPUT.PUT_LINE(v_name);
END;
```

#### 2. 블록 정의

> '블록'은 프로그래밍 언어의 `{}` 블록처럼 어떤 코드를 실행하는 단위라고 생각하면 좋을 것 같습니다.

> '블록 정의'는 PL/SQL에서 블록의 구조를 정의하는 것을 의미합니다. `BEGIN`키워드가 여기에서 사용되어서 위에서 언급이 된 것입니다.

PL/SQL은 다음과 같은 세 부분 구조를 가집니다.

| 구역 | 의미 |
| --- | --- |
| DECLARE[선언부] | 변수/상수fmf 선언합니다.(선택) |
| BEGIN[실행부] | 제어, 반복문, 함수 등 다양한 로직 기술을 실행합니다. |
| EXCEPTION | 오류 발생 시 처리 로직입니다.(선택) |
| END[종료부] | 실행된 로직의 종료를 선언합니다. |

이렇게 실행한 결과는 `DBMS_OUTPUT`에서 확인할 수 있습니다. 

#### 3. 프로시저(Procedure)

> 프로시저란, 여러 SQL문을 묶어서 만든, **함수처럼 쓰이는 하나의 실행 단위** 입니다.

프로시저는 다음과 같은 특징을 가지고 있습니다.
- 이름이 있는 "미리 정의된 작업"
- 나중에 호출만 하면 반복 실행 가능
- Oracle에서는 PL/SQL 기반으로 작성

다른 SQL 언어에서 어떻게 사용하는지는 추후에 정리하겠습니다!

#### 4. T-SQL

> T-SQL은 `Transact-SQL`의 약자로, MS-SQL에서 사용하는 SQL 확장 언어입니다.

Oracle의 PL/SQL과 비슷한 개념이지만, 문법과 동작이 다르다고 합니다.

#### 결론

> 프로시저 안에서 `BEGIN`은 블록 정의로 사용되기도 함(주의: PL/SQL, T-SQL에서는 다르게 해석됨) 이라는 문장은

같은 `BEGIN` 키워드라도 **어떤 SQL에서 쓰였는지**에 따라 완전히 다른 의미가 된다는 뜻입니다.

| SQL 종류 | 키워드 | 의미 |
| --- | --- | --- |
| 일반 SQL(MySQL 등) | `BEGIN;` | 트랜잭션 시작 |
| PL/SQL, T-SQL | `BEGIN` | 코드 블록 시작 (프로그래밍적 의미) |

<br />

## `COMMIT`과 `ROLLBACK` 키워드

이어서, 트랜잭션의 핵심 동작인 `COMMIT`과 `ROLLBACK`에 대해서 알아보려고 합니다.

### `COMMIT`의 정의

- `COMMIT`은 지금까지 수행한 모든 변경 작업을 **DB에 영구적으로 반영(저장)** 하는 명령어입니다.
- 즉, `COMMIT`을 하면 DB는 "진짜로 바뀐 것"으로 인정합니다.

#### 사용 예시

```sql
BEGIN;

UPDATE users SET balance = balance - 100 WHERE id = 1;

COMMIT;
-- 이 시점 부터는 다시 돌릴 수 없음
```

### `ROLLBACK`의 정의

- `ROLLBACK`은 지금까지 수행한 변경 작업을 **모두 취소**하고, 트랜잭션 시작 전 상태로 **되돌리는** 명령어입니다.
- 즉, DB에 "없던 일로" 만든다고 생각하면 됩니다.

#### 사용 예시

```sql
BEGIN;

UPDATE users SET balance - 100 WHERE id = 1;

ROLLBACK;
-- 이 작업은 무효 처리됨(balance 변화 없음)
```

### `COMMIT` / `ROLLBACK` 작동 흐름

- 아래와 같은 잔액 이체 sql문이 있다고 가정해 봅시다.

```sql
BEGIN;

UPDATE account SET balance = balance - 100 WHERE name = 'A';
UPDATE account SET balance = balance + 100 WHERE name = 'B';

-- 모두 성공하면
COMMIT;
-- 또는 중간에 오류가 나면
-- ROLLBACK;
```

- 해당 sql문의 시점 별 상황은 다음과 같습니다.

| 시점 | A잔액 | B잔액 | 설명 |
| --- | --- | --- | --- |
| 트랜잭션 이전 | 1000 | 500 | 초기 상태 |
| A에서 빼고 -> B에게 추가 | 900 | 600 | 변경 완료(아직 COMMIT 안됨) |
| ROLLBACK | 1000 | 500 | 변경 사항 모두 취소됨 |
| COMMIT | 900 | 600 | 변경 사항 DB에 저장됨 |

### `COMMIT` 과 `ROLLBACK`이 필요한 이유

1. 데이터 무결성 보장
  -> 여러 변경이 있을 때 일부만 반영되면 DB가 망가짐
  -> 예: A잔액 빠졌는데 B한테 입금 실패하는 경우가 생기면, DB의 무결성이 깨짐
2. 테스트 후 반영 또는 취소 가능
  -> 예: `UPDATE`로 10만 건 수정해보고, 조건 이상하면 `ROLLBACK`으로 되돌리기
3. 에러 발생 시 자동 복구
  -> 예: 중간에 네트워크 오류, 키 충돌 등 생겼을 때 전체 취소 가능





## ❓궁금증
오늘은 업무를 하다가 다음과 같은 궁금증이 생겼습니다.

> DB값과 CSV파일의 값을 비교해서 일치하는 컬럼들을 찾아야 할 때, `WHERE IN` 방식을 사용하는 것이 유리한가? 아니면 임시 테이블을 만들어서 `JOIN`을 사용하는 방식이 유리한가?

사실 JOIN이 더 유리할거라는 예상 정도는 하고 있었는데, 정확한 이유를 몰라서 자세히 찾아봤습니다.

## ❗데이터 적을 때: `WHERE IN`, 데이터 많을 때: `JOIN`
결론부터 말하자면, `JOIN` + 임시 테이블이 대량 데이터에서 훨씬 유리하다고 합니다.
- 이때, 임시 테이블에 인덱스를 걸면 `INNER JOIN`, `LEFT JOIN` 등으로 성능도 확보됩니다.
- `WHERE IN`은 비교적 소량 데이터에 적합하지만, 수천 건이 넘어가면 오히려 쿼리 파싱, 캐시, 실행 속도 등에서 비효율적이라고 합니다.

실무에서는 몇 백건 정도의 소량 데이터라면 `WHERE IN`도 OK이지만, 1000건 이상이라면 `JOIN`구조를 추천한다고 합니다.
이때, 기본적으로 임시 테이블을 만들고 조회를 하는 구문은 다음과 같습니다.

```sql
-- temp table 생성
CREATE TEMPORARY TABLE temp_company (
  name VARCHAR(255)
);

-- CSV 내용을 temp_company에 insert(IDE의 자체 Load Data 기능을 사용해도 가능)

-- JOIN으로 비교
SELECT t.*
FROM real_company t
JOIN temp_company c ON t.name = c.name;

```

### TEMPORARY 키워드가 뭐지?
제가 생각한 임시 테이블은 그냥 이름만 `temp_abc`로 짓고, 나중에 삭제하는 테이블을 생각했는데, SQL의 선구자 분들은 `TEMPORARY`라는 아름다운 키워드를 남겨 두셨다는걸 알게 되었습니다.

사실 그냥 테이블을 만드는 것과 똑같이 임시 테이블을 만들면, 운영 시에 다음과 같은 문제가 생길 수 있습니다.

| 유형 | 설명 | 영향 |
| --- | --- | ---|
| DROP 누락 | 임시 테이블 생성 후 삭제(`DROP`) 안함 | 테이블 잔존, 다른 작업에 영향 |
| 이름 중복 | 동일한 테이블명이 남아 있음 | `CREATE TABLE` 실패 또는 의도치 않은 데이터 오염 |
| 트랜잭션 롤백 미흡 | 작업 실패 후 롤백 없이 테이블 남아있음 | 예기치 않은 결과 발생 가능 |
| 공유 환경 충돌 | 다중 사용자/세션에서 동일 테이블명 사용 | 충돌, 데이터 유실 가능성 |

이 모든 것을 해결할 수 있는 키워드가 바로 `TEMPORARY`입니다.
`TEMPORARY` 키워드를 통해 테이블을 생성하면, 일반 `TABLE`과는 다르게 "임시 테이블"을 만들겠다는 의미라고 합니다.
이 `TEMPORARY TABLE`은 세션 또는 연결(Connection) 단위로만 존재하며, 자동으로 삭제되는 특별한 성격을 가집니다.

> 즉, "현재 세션에서만 유효한 임시 테이블을 만든다"는 뜻으로 `TEMPORARY`키워드를 쓴다고 합니다.

`TEMPORARY`를 사용하여 만든 임시 테이블에는 다음과 같은 특징이 있습니다.
#### 1. 세션 범위 제한
- 테이블은 생성한 DB 세션(=DB 연결) 에서만 접근이 가능합니다. 당연하겠지만 새 세션을 열면 테이블이 안 보인다는 주의사항도 있습니다.
#### 2. 자동 삭제
- 세션이 종료되면 자동으로 삭제됩니다.(명시적 DROP이 불필요 합니다. 그럼에도 명시적으로 `DROP TEMPORARY TABLE`을 하는 것이 안전하다고 합니다.)
#### 3. 다른 사용자와 격리
- 동일한 이름의 TEMPORARY TABLE을 여러 세션이 동시에 생성이 가능합니다.
#### 4. 테이블 명은 겉보기엔 같아도 내부적으로는 고유함
- DB가 세션 ID 등을 기반으로 내부적으로 구분 처리를 합니다.
#### 5. 퍼포먼스 최적화
- 일부 DB는 temp영역을 메모리 기반으로 처리하여 빠릅니다.
#### 6. 트랜잭션 롤백과 무관
- 트랜잭션이 롤백되어도 temp table 자체는 유지됩니다. (이 부분은 주의해야 하는데, 아래서 자세히 설명하겠습니다.)


## 둘이 구조적으로 어떤 차이가 있는 거지?
사실 JOIN이 더 유리하다는 결과가 나왔지만, 정확히 내부적으로 어떤 동작을 하길래 이렇게 되는지는 여전히 의문이 남아 있었습니다.

`WHERE IN 절` VS `임시 테이블 JOIN`이 성능에서 구조적으로 차이가 나는 이유는, DB 내부의 실행 계획(Execution Plan), 메모리 관리 방식, 파싱 처리, 인덱스 활용 가능성 등에서 결정된다고 합니다.

### `WHERE IN` 절의 구조적 동작 방식

```sql
SELECT * FROM customers WHERE name IN ('홍길동', '김철수', '이영희', ...);
```
해당 쿼리를 실행할 때, DB 엔진 내부의 처리 흐름은 다음과 같습니다.

1. `IN`리스트를 파싱 -> 내부 메모리(Set 구조 등)에 적재
2. `name` 값이 이 리스트에 있는지 하나하나 비교(Nested Loop 기반)
3. 리스트가 커질수록 메모리 점유 + 비교 비용 증가

해당 방식에는 다음과 같은 한계가 있다고 합니다.

- 수천 건 이상을 조회 할 때는, SQL 파싱 자체가 무거워짐.
- 리스트 길이 제한 (Oracle의 경우에는 약 1000개)
- 인덱스를 활용하기 어려운 경우가 있음(조건이 복잡해질 때)

### `JOIN with temp_table`의 구조적 동작 방식

```sql
SELECT * 
FROM customers c
JOIN temp_name_list t ON c.name = t.name;
```
해당 쿼리를 실행할 때, DB 엔진 내부의 처리 흐름은 다음과 같습니다.

1. `temp_name_list`테이블을 `FROM` 절에서 먼저 스캔
2. 조인 키(예: `name`)에 인덱스가 있다면 해시 조인, 병합 조인 등으로 효율적 실행
3. Execution Plan 최적화 가능

`WHERE IN` 방식과 비교하여, 해당 방식에는 다음과 같은 장점이 있다고 합니다.

- `temp_table`에 인덱스를 생성할 수 있어 탐색 성능이 높아짐.
- 복합 조건(name, address, birthdate 등)도 효율적 조인 가능
- DB 옵티마이저가 다양한 조인 알고리즘으로 최적화 가능(Nested Loop, Hash Join, Merge Join)

### 두 가지의 구조적인 핵심 차이점 요약

| 항목 | `WHERE IN` 방식 | `JOIN with temp_table` 방식 |
| --- | --- | --- |
| 쿼리 파싱 | IN 리스트가 길면 파싱 비용 증가 | 쿼리 구조는 동일, temp_table 만 관리 |
| 메모리 처리 | DB가 IN 리스트를 메모리상 직접 비교 | DB가 조인 알고리즘으로 최적화 |
| 인덱스 활용 | 어렵거나 무시될 수 있음 | temp_table에 인덱스 사용 가능 |
| Execution Plan | 제한적(조건 1개 비교 중심) | 조인 조건 최적화, 다중 조건 유연 |
| 확장성 | 수천 건부터 급격한 성능 저하 | 수만 ~ 수십만 건도 처리 가능 |

AI의 말을 빌려서 비유적으로 정리하면,
> `IN 절`은 -> "질문을 한꺼번에 1000명한테 다 해보고 하나라도 맞는지 확인"

> `JOIN 절`은 -> "미리 명단을 정리한 종이에 이름이 있는 사람만 통과"

따라서, JOIN 방식이 훨씬 구조화되고 인덱스 기반 처리로 CPU, 메모리, I/O 부담을 줄여준다고 합니다.

정리를 해 보니, 큰 차이점은 해시 조인, 병합 조인 등의 효율적 실행인 것 같은데, 이 부분을 제가 잘 몰라서, 추가적인 정리가 필요할 것 같습니다.
또한, Execution Plan에 대해서도 잘 알지 못해서, 다른 문서로 나눠서 정리해볼 계획입니다.

## TEMPOARAY 테이블의 롤백에 대하여

TEMPORARY 키워드를 사용하여 임시 테이블을 만들고 사용할 때 주의할 점이 있다고 하는데, 바로 다음과 같다고 합니다.

> TEMPORARY 테이블은 트랜잭션 롤백과 무관하기 때문에, 롤백되어도 임시 테이블이 남는다.

이게 무슨 얘기인지 잘 이해가 안 가서, 간단히 정리하였습니다.

우선 트랜잭션이란, **"하나의 논리적인 작업 단위"** 를 말합니다. 
롤백이란, **"지금까지 한 작업을 취소(DB에서 없던 일로) 하는 것"** 입니다. 

그런데, TEMPORARY 키워드를 사용해 만든 임시 테이블은 롤백과 무관하다고 합니다. 그 이유는,

#### 1. 트랜잭션은 보통 데이터(행)에 대해서만 적용됩니다.
- 예시로, `INSERT`, `UPDATE`, `DELETE` 같은 DML

#### 2. 그런데 테이블 자체의 생성/삭제는 DDL 이기 때문에, 트랜잭션과는 별개입니다.

이와 관련해서, 예제를 하나 보겠습니다.

```sql
BEGIN;  -- 트랜잭션 시작

CREATE TEMPORARY TABLE temp_user (name VARCHAR(100));  -- 임시 테이블 생성
INSERT INTO temp_user VALUES ('홍길동');  -- 값 삽입

ROLLBACK;  -- 롤백해도 테이블과 홍길동 데이터 여전히 존재합.
```

주의해야 할 점은, **테이블이 롤백되지 않는 것은 물론이고, 그 안의 데이터도 롤백되지 않는다** 고 합니다.

### TEMPORARY로 만든 임시 테이블의 롤백 불가능이 중요한 이유

**오해를 막기 위해서** 라고 합니다. 
- 많은 사람들이 "롤백하면 임시 테이블도 사라지겠지?" 라고 착각할 수 있다고 합니다. (특히 저 같은 사람들...?ㅋㅋㅋ)
- 하지만 실제로는 `ROLLBACK`을 해도 임시 테이블은 그대로 남아 있어서,
    - 다음 쿼리에서 다시 사용하게 되거나,
    - 충돌/중복 테이블 문제로 이어질 수 있다고 합니다.

그래서 실무에서는 다음과 같이 사용한다고 합니다.

```sql
BEGIN;

DROP TEMPORARY TABLE IF EXISTS temp_company;
CREATE TEMPORARY TABLE temp_company (...);
INSERT INTO temp_company VALUES (...);

-- 작업 실패 시 ROLLBACK, 성공 시 COMMIT
ROLLBACK; -- 이 경우에도 temp_company는 남아 있음
```

이런 식으로 **명시적으로 DROP** 하거나, 세션 종료로 자동 정리를 기대하는 방식으로 쿼리문을 짜야 한다고 합니다.
그런데 저기서 저 `BEGIN` 키워드는 무엇일까요...? 이것은 다음 글에 적겠습니다.

## 1. 개요

* **Crontab**은 리눅스에서 특정 작업을 **시간 기반으로 자동 실행**하기 위한 스케줄러
* 주로 다음 용도로 사용됨

  * 배치 작업
  * 로그/파일 정리
  * DB 백업
  * 외부 시스템 연계 호출
* 운영 서버 장애의 **주요 원인 중 하나**이며, 특히 특정 시간대 반복 장애와 강하게 연관됨

---

## 2. Crontab 스케줄 형식

```
분  시  일  월  요일
```

예시:

```
0 8 * * *
```

* 매일 오전 8시 0분에 실행
* 서버 시간대(KST/UTC)에 따라 실제 실행 시각이 달라질 수 있음

---

## 3. Crontab 확인 위치 (전수 조사 기준)

### 3.1 사용자 크론탭

```bash
crontab -l
sudo crontab -u root -l
sudo crontab -u <username> -l
```

* 현재 계정 외에도 `root`, 서비스 계정에 크론이 존재하는 경우가 많음

---

### 3.2 시스템 크론탭

#### `/etc/crontab`

```bash
cat /etc/crontab
```

* 사용자 필드가 포함된 시스템 전역 크론

---

#### `/etc/cron.d/`

```bash
ls -l /etc/cron.d/
cat /etc/cron.d/<file>
```

* 패키지 설치 시 자동 등록되는 크론이 위치
* 보안 점검, 백업, 로그 정리 작업이 주로 포함됨

---

### 3.3 주기 디렉토리 기반 크론

```bash
ls -l /etc/cron.hourly/
ls -l /etc/cron.daily/
ls -l /etc/cron.weekly/
ls -l /etc/cron.monthly/
```

* 시간은 `/etc/anacrontab`에 의해 관리됨
* 명시적인 실행 시간이 보이지 않아 추적이 어려움

---

## 4. 실행 스크립트 분석 절차

1. 스크립트 존재 여부 확인

```bash
ls -l /path/to/script.sh
```

2. 내용 확인

```bash
cat /path/to/script.sh
```

3. 실행 권한 확인

```bash
chmod +x script.sh
```

---

## 5. Crontab 실행 환경의 특징 (중요)

### 5.1 PATH 제한

* 크론은 로그인 쉘 환경을 로드하지 않음
* `.bashrc`, `.profile` 등이 적용되지 않음
* **모든 명령은 절대경로 사용 필요**

```bash
/usr/bin/java
/usr/bin/mysql
```

---

### 5.2 권한 및 계정

* 크론은 **등록된 사용자 권한으로 실행**
* 파일/디렉토리 접근 권한 불일치 시 조용히 실패할 수 있음

---

## 6. Crontab 로그 확인

```bash
grep CRON /var/log/syslog
```

---

## 7. 문제 발생 시 점검 체크리스트

* 사용자 크론탭만 확인하고 종료하지 않았는가
* `/etc/cron.d`, `/etc/cron.*` 디렉토리를 확인했는가
* 스크립트가 실제로 존재하는가
* 절대경로를 사용하고 있는가
* 실행 로그가 남는 구조인가
* 서버 시간대(KST/UTC)를 확인했는가

---

## 8. 정리

* `crontab -l`만 확인하는 것은 불충분
* 운영 서버에서는 **크론 전수 조사가 기본 작업**
* 특정 시간대 반복 장애 발생 시, 크론은 최우선 점검 대상


---

## 9. Crontab을 대체할 수 있는 방법 (Non-Legacy 프로젝트 기준)

> 결론부터 말하면, **신규 프로젝트에서 크론은 1순위 선택지가 아니다.**
> “쓸 수는 있지만, 의도적으로 선택해야 하는 기술”이다.

---

## 9.1 systemd timer (서버 단 대체 수단, 가장 현실적)

### 개요

* 리눅스의 `systemd` 기반 타이머
* cron과 동일한 역할을 수행하지만 **운영 통제력은 훨씬 강함**

### 특징

* 서비스(`.service`)와 타이머(`.timer`)가 분리됨
* 상태 확인 가능 (`active / failed`)
* 로그가 `journalctl`로 **표준화**
* 서버 부팅 지연 실행, 실패 재시도 설정 가능

### 왜 크론보다 나은가

* 실행 성공/실패를 **명확히 추적 가능**
* “조용히 실패”하지 않음
* 운영 서버에서 장애 분석이 훨씬 수월

### 언제 쓰는 게 맞는가

* 단일 서버
* OS 레벨 작업 (백업, 로그 정리, 배치 실행)
* 컨테이너 미사용 환경

➡ **크론을 대체하는 1순위 (서버 기반)**

---

## 9.2 Spring @Scheduled (애플리케이션 레벨)

### 개요

* Spring Boot에서 제공하는 내부 스케줄링 기능

```java
@Scheduled(cron = "0 0 8 * * *")
public void job() {
    ...
}
```

### 장점

* 코드와 함께 버전 관리됨
* 트랜잭션, DI, 설정값 활용 가능
* 별도 서버 크론 관리 불필요

### 단점

* **멀티 인스턴스 환경에서 중복 실행**
* 서버 재시작 시 실행 누락 가능
* 장애 발생 시 “언제 실행됐는지” 추적 어려움

### 언제 써야 하나

* 단일 인스턴스
* 중요도가 낮은 주기 작업
* 내부 정리성 작업

➡ **운영 핵심 배치는 부적합**

---

## 9.3 메시지 큐 + 워커 구조 (권장)

### 개요

* 스케줄러는 “이벤트 생성”
* 실제 작업은 워커가 소비

구조 예:

```
Scheduler → Message Queue → Worker
```

### 장점

* 재시도 / 장애 복구 가능
* 수평 확장 가능
* 작업 실패 시 재처리 가능
* 실행 이력 추적 가능

### 단점

* 구조 복잡
* 초기 설계 비용 큼

### 언제 쓰는가

* 신규 서비스
* 중요 배치
* 대용량 데이터 처리
* 장애 복구가 중요한 시스템

➡ **레거시가 아닌 프로젝트의 정석**

---

## 9.4 외부 스케줄러 / 워크플로우 엔진

### 예시 역할

* 배치 흐름 관리
* 의존성 있는 작업 순차 실행
* 실패 시 알림 및 재시도

### 특징

* “한 번에 끝나는 작업”이 아니라
* **업무 흐름 단위 관리**

### 언제 필요?

* ETL
* 데이터 파이프라인
* 정산 / 통계 / 리포트

➡ 단순 크론 대체가 아니라 **운영 성숙 단계용**

---

## 9.5 컨테이너 환경 (Kubernetes 기준)

### 개요

* CronJob 리소스로 스케줄링

### 장점

* 실행 이력 관리
* 실패 재시도
* 컨테이너 격리
* 배포/버전 관리 명확

### 크론과의 차이

* 서버에 접속해서 관리하지 않음
* 인프라 선언 코드로 관리

➡ **클라우드 네이티브 환경의 표준**

---

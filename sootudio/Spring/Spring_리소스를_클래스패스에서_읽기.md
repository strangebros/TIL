## ❓ 궁금증

> 워키 프로젝트를 하면서, 개발 기간을 많이 늦추는 일이 하나 발생했습니다.
>
> SpringBoot로 만든 백엔드 어플리케이션에 FCM(서버 SDK)를 붙히는 작업을 하고 있었는데, 로컬에서는 잘 되는 기능이 서버에 배포하면 500(서버 오류)만 나오는 문제를 겪었습니다.
>
> 이에 Firebase에 대한 이해도가 부족하다고 생각했지만, 결론적으로 Spring 배포 시의 키 경로를 잘못 설정한 바람에 생긴 문제였어서... Spring에 대해 더욱 공부할 필요성을 느꼈기에, 해당 이슈와 해결 과정을 정리합니다.

## 상황 요약

- FCM 테스트 API를 만들었습니다.
- 로컬(Postman)에서 해당 기능을 테스트할때는 정상으로 나왔습니다.
  
  ```json
  {
    "status" : 500,
    "message" : "FCM 메시지 전송에 실패했습니다."
  }
  ```
  -  `CustomException`을 사용했기 때문에, 상태만 500이고, 메시지는 저런 식으로 나오는 게 맞습니다.
  -  서버단에서 단독으로 200이 나오는 테스트를 못 하기 때문에, 이렇게 기능이 완성됐다고 생각하고 배포를 진행했습니다.

- 그런데, 서버를 배포하고 Swagger에서 테스트 하니 해당 기능이 예상과 다르게 오류가 나는 것을 확인했습니다.
  
  ```json
  {
    "status" : 500,
    "message" : "서버 내부 오류 발생!"
  }
  ```
  
  - 똑같이 500이 떨어지는 건 맞았지만, 제가 설정한 `CustomException`의 예외가 아닌, 기본 500이 떨어지고 있었습니다.
  - 또한, 로그를 살펴보니 해당 요청을 보낼 때 불필요한 스택트레이스가 엄청나게 많이 찍힌다는 것을 확인하였습니다.

- 로그 내부에서 `HttpMediaTypeNotSupportedException` (Content-Type 문제) 도 확인되었습니다.
- DTO에서 전달하는 `Token`의 문제인가 하여 토큰 검증 로직을 추가했지만, 이것도 원인이 아니였습니다.
- 따라서, **FCM 호출 전에 무언가 잘못되어 컨트롤러/서비스의 커스텀 예외로 변환되기 전에(비즈니스 로직에 도달하기 전에) 500 에러가 발생한다는 것**을 알 수 있었습니다.

## 원인

- ~GPT를 통해~ 밝혀낸 원인은 **Firebase 서비스 계정 키를 "파일 경로"로 읽고 있었던 문제였습니다.
- FCM 기능을 넣으려면, Firebase에서 key를 발급받아 저장해야 하는데, 저는 해당 경로를 다음과 같이 설정했습니다.

```java
new FileInputStream("src/main/resources/firebase/fb-key.json")
```

- 해당 경로는 로컬 IDE에서 테스트를 할 때는 `src/main/...`이라는 경로가 실제 파일로 존재하기 때문에, **동작하는 것 처럼** 보였습니다.
- 하지만, 배포 시에는 **서버(JAR) 파일에서는 패키징을 하며 리소스가 JAR 파일 내부로 들어가서** `src/main/resources/...`라는 파일 경로가 더 이상 없다고 합니다.
- 따라서, 서버에서는 해당 경로가 없으니, FCM 호출 기능 테스트에서 실패를 하고, 기본 500 에러로 내보냈던 것입니다.

## 해결 방법

- 해결 방법은 간단했는데, **리소스를 "*클래스패스"로 읽는 것**이었습니다.

방법을 설명하기 전에 간단하게 클래스패스의 개념에 대해서 설명하고 가겠습니다.

**클래스패스(Classpath)**
- 클래스패스는, 자바가 클래스를 사용하려고 탐색을 할 때 JVM 혹은 자바 컴파일러가 사용하는 파라미터 입니다.
- 즉, **클래스나 패키지를 찾을 때 기준이 되는 경로**를 의미합니다.
- java 기반의 프로그램을 실행할 때, 소스 코드(`.java`)를 컴파일하면 바이트코드(`.class`)로 변환되고, JVM이 바이트코드로 된 파일을 실행하려면 찾아야 하는데, 이 바이트코드까지의 경로를 클래스패스라고 합니다.

이전에 제가 로컬에서 사용한 코드를 다시 보겠습니다.

```java
new FileInputStream("src/main/resources/firebase/fb-key.json")
```

- 해당 방식은 클래스패스 읽기 방식이 아니라, 프로젝트 폴더 내 실제 파일 경로를 직접 읽는 방식입니다.
- 그래서, 수정한 리소스 읽기 방식은 아래와 같이 바뀌었습니다.

```java
InputStream in = new ClassPathResource("firebase/fb-key.json").getInputStream())
```

- 위 방식처럼 클래스패스 전용 API(`ClassPathResource`)를 사용해서 키를 받아 와야 `JAR` 제대로 된 경로에서 우리가 설정해놓은 위치로 들어가는 것입니다.
- 해당 방식은 꼭 배포가 아니라도 로컬에서도 똑같이 적용 가능하기 때문에, 처음부터 클래스패스를 사용해서 개발하는 것이 좋다고 합니다.

## 결과

- 우선 Swagger에서도 아래와 같이 테스트 메시지가 잘 나왔습니다.

```json
{
  "status" : 500,
  "message" : "FCM 메시지 전송에 실패했습니다."
}
```
- (이거 성공한 거 맞습니다... `CustomException`으로 잘 잡힌거)

- 그리고, 안드로이드/IOS 개발자 분들에게 올바른 토큰 값으로 테스트를 부탁드린 결과, 잘 나오는 것을 확인할 수 있었습니다.
- ![1000021436](https://github.com/user-attachments/assets/0be3f525-2c5a-459f-80ee-955666bfc402)

- 사소한 문제 때문에 시간을 너무 많이 잡아먹은 것 같아서 아쉬움도 있었지만, 지식을 더 단단하게 다지고 가자는 의미에서 정리를 해 봤습니다.
- 앞으로도 개발할 때 나오는 사소한 실수들, 그리고 배움들을 잘 정리해 보겠습니다!



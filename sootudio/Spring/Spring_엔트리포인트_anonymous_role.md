## 문제 상황
- 레거시 Spring 프로젝트에 신규 API를 추가하고 Swagger에서 테스트했다.
- Swagger에서 Authorize로 토큰을 등록한 상태로 호출하면 `AuthenticationEntryPoint` 예외(401)가 발생했다.
- 반대로 Swagger에서 로그아웃(= 요청 헤더에 토큰 없음)하고 호출하면 정상 응답이 왔다.
- 같은 Swagger 안의 기존 API들은 토큰이 있어야만 호출되는데, 문제 API만 반대로 동작했다.

---

## 원인 (핵심)
### DB 기반 “URI → ROLE” 권한 매핑이 `ROLE_ANONYMOUS`로 등록되어 있었다
- 해당 API URI의 권한이 `ROLE_ANONYMOUS`로 설정되어 있어 익명 접근이 허용된 상태였다.
- 그래서 토큰이 없을 때는 익명으로 통과하여 호출이 됐다.
- 그런데 토큰이 포함되면 Security 필터가 인증/인가 흐름을 타면서(프로젝트 구현/정책에 따라) 인증 예외가 발생해 EntryPoint(401)로 떨어질 수 있다.

> 참고: `@SecurityRequirement`는 Swagger 문서/UI 설정에 가깝고, 실제 인증/인가 결정은 서버의 Security 설정 + 권한 데이터(URI→ROLE)가 한다.

---

## 해결
- 권한 테이블에서 문제 API URI에 매핑된 ROLE을 확인했다.
- `ROLE_ANONYMOUS` → 기존 API와 동일하게 `ROLE_USER`로 변경했다.

### 결과
- 토큰을 넣으면 정상 호출
- 토큰을 빼면 401/403으로 차단 (기대 동작)

---

## 추가 이슈: 로컬 OK, 개발서버 Swagger는 여전히 실패 (DB는 동일)
DB는 같아도 개발서버에서 동작이 유지되면 아래가 가장 유력하다.

### 1) 권한 매핑 캐시/메모리 로딩
- 서버가 기동 시 DB에서 권한을 읽어 캐싱하고 요청 시 DB를 다시 보지 않는 구조일 수 있다.
- DB 수정 후에도 반영이 안 된다.
- 조치: 개발서버(또는 LB 뒤 모든 인스턴스/Pod) 재기동, 캐시 무효화/리로드 확인

### 2) 실제로는 다른 스키마/계정/테이블을 조회
- 같은 DB 서버를 쓴다고 해도 스키마(예: dev/real)나 계정, 테이블이 달라 착각할 수 있다.
- 조치: 개발서버가 사용하는 datasource 기준으로 권한 테이블을 직접 조회해서 값 확인

### 3) 요청 URI 불일치
- 개발서버는 contextPath, 리버스 프록시 리라이트 등으로 실제 요청 URI가 달라질 수 있다.
- DB에서 수정한 URI와 매칭이 안 되어 계속 실패처럼 보일 수 있다.
- 조치: 개발서버 access log에서 실제 Request URI 확인 후 권한 테이블 매칭 점검

---

## 재발 방지 체크리스트
- [ ] 신규 API 추가/경로 변경 시 권한 테이블에 URI가 어떤 ROLE로 등록되는지 확인 (기본값 주의)
- [ ] URI 패턴/정규식/우선순위 규칙 확인 (중복 엔트리 위험)
- [ ] 권한 매핑이 캐시되는지 확인 (변경 반영에 재기동/캐시 갱신 필요)
- [ ] 환경별 실제 요청 URI(contextPath/리라이트) 차이 점검
- [ ] LB 뒤 다중 인스턴스면 전부 반영됐는지 확인

---

## 한 줄 요약
“토큰 넣으면 401(EntryPoint), 토큰 없으면 성공”은 컨트롤러 문제가 아니라
대부분 **보안 정책(URI→ROLE) 데이터 오류** 또는 **캐시 반영 문제**다.

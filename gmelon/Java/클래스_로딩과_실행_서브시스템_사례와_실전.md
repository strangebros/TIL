## **9. JVM 클래스 로딩과 실행 서브시스템: 소개 및 실제 적용 사례**

## **9.2 사례 연구**

## **9.2.1 톰캣: 정통 클래스 로더 아키텍처**

- **톰캣, 제티 등 주류 자바 웹 서버는 다수 웹 애플리케이션 배포를 위해 둘 이상의 자체 정의 클래스 로더 혼용**
    - **웹 애플리케이션별 클래스 라이브러리 격리**: 애플리케이션마다 다른 버전의 서드 파티 라이브러리 독립적 사용 보장 필요
    - **자바 클래스 라이브러리 공유**: 둘 이상의 웹 애플리케이션 간 동일 라이브러리 공유 가능해야 함
        - **자원 낭비 방지**: 스프링 프레임워크열 번 복사 관리 시 디스크 공간 및 메모리 낭비 방지
        - **메서드 영역 과도한 확장 방지**: 클래스 라이브러리 공유 불가 시 가상 머신메서드 영역확장 위험 방지
    - **서버 보안 유지**: 서버는 애플리케이션 배포 영향 없이 보안 유지 필요
    - **서버의 클래스 라이브러리 의존성**: 많은 주류 자바 서버가 자바 언어로 구현되어 서버 자체 라이브러리 의존성 문제 발생
        - **애플리케이션 라이브러리와의 독립성**: 보안상 서버 라이브러리는 애플리케이션 라이브러리와 독립적이어야 함
    - **JSP 핫 스와프 지원**: 웹 서버의 대부분 JSP 핫 스와프지원
        - **JSP 파일의 수정 가능성**: JSP 파일은 런타임에 서드 파티 라이브러리나 자바 코드보다 수정 가능성 높음
        - **수정 후 재시작 불필요**: ASP, PHP 등과 같이 JSP 코드도 애플리케이션 재시작 없이 수정 가능
        - **예외 사례**: 웹로직 서버는 프로덕션 모드에서 기본적으로 JSP 파일 변경 불허용 경우도 있음
- **톰캣의 클래스 라이브러리 저장 디렉터리 및 클래스 로더 구조 (톰캣 5까지)**
    - **핵심 디렉터리**: 톰캣은 4개의 디렉터리(`/common/`, `/server/`, `/shared/`, `/WEB-INF/`) 활용
    - **디렉터리별 클래스 라이브러리 이용 범위**:
        - **`/common`**: 톰캣 자신과 모든 웹 애플리케이션
        - **`/server`**: 톰캣 자신
        - **`/shared`**: 톰캣을 제외한 모든 웹 애플리케이션
        - **`/WEB-INF`**: 해당 웹 애플리케이션
    
    - **톰캣 5까지 클래스 로더 아키텍처**: 다수 클래스 로더를 이용한 디렉터리 구조 및 용도에 맞는 클래스 라이브러리 로드 및 격리
        - **전통적인 부모 위임 모델**: JDK기본 클래스 로더 위에 톰캣자체 클래스 로더들이 부모 위임 모델 따름
        - **CommonClassLoader**: /common 디렉터리 클래스 담당
        - **CatalinaClassLoader (서버 클래스 로더)**: /server 디렉터리 클래스 담당
        - **SharedClassLoader (공유 클래스 로더)**: /shared 디렉터리 클래스 담당
        - **WebappClassLoader (웹 앱 클래스 로더)**: /WebApp/WEB-INF 디렉터리 클래스 담당, 웹 앱당 여러 인스턴스 존재 가능
        - **JsperLoader (JSP 클래스 로더)**: JSP 파일 컴파일 클래스 파일로 클래스 범위 한정. JSP 파일 수정 감지 시 새 인스턴스 생성 및 교체를 통한 핫 스와프구현
        - **격리 및 공유 원칙**
            - **공통 클래스 로더 로드 클래스**: 카탈리나 및 공유 클래스 로더 모두 사용 가능
            - **카탈리나 및 공유 클래스 로더 로드 클래스**: 서로 격리됨
            - **웹 앱 클래스 로더 인스턴스**: 공유 클래스 로더가 로드한 클래스 이용 가능하나, 각 인스턴스는 서로 독립적
    
    ![image.png](attachment:e96e15fe-da12-4530-84fa-499b92914061:image.png)
    
- **톰캣 6 이후의 클래스 로더 아키텍처 단순화:**
    - **기본 디렉터리 구조 단순화**: CommonClassLoader가 서버(카탈리나) 클래스 로더와 공유 클래스 로더 역할 모두 수행
    - common, server, shared 디렉터리를 lib 디렉터리 하나로 병합 권장
        - 이전 common 디렉터리 클래스 라이브러리와 동일 역할 수행, 대부분의 배포 시나리오 단순화
- **톰캣클래스 로더 아키텍처의 특징: 권장되는 '정통' 방식을 따르므로 명확하고 이해하기 쉬움**

## **9.2.2 OSGi: 유연한 클래스 로더 아키텍처**

- **OSGi 소개:**
    - **정의**: IBM 등이 제창한 자바 기반의 '동적' 모듈 명세
    - **초기 목적**: 서비스 제공자가 다양한 가정용 스마트 기기를 하나의 게이트웨이를 통해 제공하는 것
    - **현재 지위**: 자바의 다른 기술 영역에서도 잘 받아들여져 자바 세계의 '실질적인' 동적 모듈표준으로 자리매김
    - **주요 응용 분야**: 스마트 시티, 스마트 농업, 4차 산업 등
    - **가장 잘 알려진 응용 예**: 이클립스 통합 개발 환경, 재즈 플랫폼, IBM 글래스피시 서버, JBoss 등 대규모 소프트웨어 플랫폼과 미들웨어
- **OSGi 모듈(번들)의 특징:**
    - **일반 자바 클래스 라이브러리와 유사**: 자바 패키지와 클래스를 일반 JAR 형태로 패키징
    - **의존성 및 공개 패키지 선언**: 번들은 의존하는 패키지 선언(Import-Package) 또는 외부에 공개할 패키지 선언(Export-Package) 가능
    - **정밀한 클래스 라이브러리 가시성 제어**: 모듈이 명시적으로 공개한 패키지만 외부 접근 가능
    - **JDK 9 자바 모듈 시스템과의 중복 및 차이점**:
        - **정적 모듈 기능 중복**: OSGi의 '정적' 모듈 기능은 JDK9 자바 모듈 시스템과 중복
        - **'동적' 모듈 시스템 개선 집중**: 현재 OSGi는 '동적' 모듈 시스템개선에 집중
        - **호환성 의미**: OSGiR7부터 JDK9 모듈 시스템지원, 호환 의미일 뿐 중복 기능 통합은 아님
- **OSGi 도입의 주된 이유: 모듈 수준에서 핫 스와프(Hot Swap) 구현 용이성**
    - **기능**: 프로그램 업데이트 또는 디버깅 시 일부만 '비활성화 → 재설치 → 활성화' 가능
    - **제약 사항**: 메모리 관리 및 핫 스와프 후 문맥 상태 유지 등 복잡한 요소 고려 필요, 항상 가능하지는 않음
    - **예시:** 이클립스에서 재시작 없이 플러그인 설치, 제거, 업데이트 시 OSGi 사용 (!!)
- **OSGi의 유연한 클래스 로더 아키텍처: OSGi가 매력적인 기능 제공 가능 근간은 유연한 클래스 로더 아키텍처에 있음**
    - **고정된 위임 관계 부재**: OSGi번들 클래스 로더들 사이에 고정된 위임 관계 없음, 대신 몇 가지 규칙 존재
    - **패키지 의존성에 따른 위임**: 번들 A가 번들 B의 패키지 b1에 의존 선언 시, 패키지 b1 클래스 로딩은 번들 B 클래스 로더에 위임됨
    - **독립성**: 특정 패키지로 서로 연관되지 않은 번들 클래스 로더끼리는 서로 독립적임
    - **접근 범위 제어**: 번들 클래스 로더는 다른 번들에 서비스 제공 시 공개 목록(Export-Package) 기반 접근 범위 엄격 제어
        - **번들 내부 클래스**: 번들에 포함된 클래스는 해당 번들 클래스 로더가 찾아 로딩 가능
        - **공개 목록 미명시 클래스**: 공개 목록에 명시되지 않은 클래스는 다른 번들에서 로딩 요청 시 OSGi 프레임워크가 해당 요청을 이 번들에 할당하지 않음
    
    ![image.png](attachment:288a0aa2-eeb4-4b66-b560-77d7fd14db0c:image.png)
    
    - **OSGi클래스 로딩 시 조회(lookup) 규칙**:
        - `java.*`로 시작하는 클래스 로딩은 부모 클래스 로더에 위임
        - 위임 목록 클래스 로딩은 부모 클래스 로더에 위임
        - 의존 목록 클래스 로딩은 해당 클래스에 의존하는 번들 클래스 로더에 위임
        - 현재 번들 클래스패스 조회, 자체 클래스 로더 사용 로드
        - 자체 프래그먼트 번들 확인, 있다면 해당 프래그먼트 번들 클래스 로더에 위임
        - 번들의 동적 의존 목록 찾아 해당 번들 클래스 로더에 위임
        - 그 외 경우 클래스 조회 실패
    - **부모 위임 모델 미준수**: OSGi는 부모 위임 모델을 따르지 않음
- **OSGi클래스 로더 아키텍처의 위험: 유연하지만 여러 위험 존재**
    - **교착 상태 발생 가능성**: 복잡한 모듈 의존 관계 및 높은 동시성 시스템에서 교착 상태 발생 빈번
        - **원인**: 번들 A가 번들 B에, 번들 B가 번들 A에 의존 시, 클래스 로딩과정에서 서로 락을 기다리느라 교착 상태 발생 가능성 높음
        - **과거 해결책**: 이클립스 버그 목록 관련 문제 다수 존재. `osgi.classloader.singleThreadLoads` 매개 변수 `true` 지정으로 클래스 로딩 단일 스레드 처리 우회법 제시 (성능 이슈)
        - **JDK 7 이후 해결책**: ClassLoader에 `registerAsParallelCapable()` 메서드 추가, 병렬 클래스 로딩 명시적 선언 가능. 동기화 범위가 객체 자체에서 로드할 클래스 이름 단위로 정밀해짐
- **OSGi의 활용 및 한계:**
    - **장점**: 모듈 단위 개발 목표 달성에 필요한 다양한 서비스 정의 및 구현 제공, 성숙한 프레임워크 다수 존재
    - **단점 및 한계**: 강력한 기능만큼 복잡하여 추가적인 위험 감수 필요, 모든 애플리케이션에 적합하지는 않음

## **9.2.3 바이트코드 생성 기술과 프락시 구현**

### **바이트코드 생성 기술 개요**

> 여기서 말하는 바이트 코드 생성 기술은, 특정 고급 라이브러리(Javassist, CGLib, ASM)를 다루는 기술을 말하는 건 아님
> 
- **javac 컴파일러:**
    - **조상 기술**: JDK에 포함된 javac 컴파일러는 바이트코드 생성기술의 '조상'
- **javac 외의 바이트코드 생성 예시:**
    - **웹 서버의 컴파일러**: JSP 코드 컴파일
    - **AOP(Aspect-Oriented Programming) 프레임워크**: 컴파일타임에 코드 변경하여 AOP 기능 구현
    - **동적 프락시 기술**: 런타임에 바이트코드 생성하여 AOP 기능 구현
    - **리플렉션**: 가상 머신이 실행 속도 개선을 위해 런타임에 바이트코드 생성

### **동적 프락시 기술**

- 스프링에서의 활용:
    - 스프링은 `java.lang.reflect.Proxy` 직접 사용 또는 `java.lang.reflect.InvocationHandler` 구현 없이도 인터페이스로부터 생성한 빈(bean)이라면 내부적으로 동적 프락시 활용하여 기능 수행
- **'동적'의 의미: 프락시 클래스를 자바 코드를 사용하여 '정적'으로 작성하는 일**
- **동적 프락시의 장점:**
    - **코드 양 감소**: 프락시 클래스 작성 코드 양 감소
    - **유연한 재사용성**: 원래 클래스 및 인터페이스를 알 수 없는 상태에서 프락시가 행위를 대신 결정 가능, 다양한 애플리케이션 시나리오에서 유연한 재사용 가능
- **간단한 동적 프락시 예시 분석**
    
    ```java
    public class DynamicProxyTest {
        interface IHello {
            void sayHello();
        }
        
        static class Hello implements IHello {
            @Override
            public void sayHello() {
                System.out.println("hello world");
            }
        }
    }
    ```
    
    ```java
    static class DynamicProxy implements InvocationHandler {
        Object originalObj;
        
        Object bind(Object originalObj) {
            this.originalObj = originalObj;
            return Proxy.newProxyInstance(
                originalObj.getClass().getClassLoader(),
                originalObj.getClass().getInterfaces(), 
                this);
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
            System.out.println("Welcome");
            return method.invoke(originalObj, args);
        }
    }
    ```
    
    ```java
    public static void main(String[] args) {
        IHello hello = (IHello) new DynamicProxy().bind(new Hello());
        hello.sayHello();
    }
    
    // 실행 결과
    Welcome
    hello world
    ```
    
    - **기능**: 원래 코드는 "hello world" 출력, 프락시 클래스는 원래 클래스 메서드 실행 전 "Welcome" 출력
    - `Proxy.newProxyInstance()` 메서드
        - `IHello` 인터페이스 구현 및 `Hello()` 코드 동작 대행하는 프락시 인스턴스 반환
    - **내부 동작**: 검증, 최적화, 캐싱, 동기화, 바이트코드 생성, 명시적 클래스 로딩등의 작업 수행

### **디컴파일된 동적 프락시 클래스 분석**

```java
final class $Proxy0 extends Proxy implements DynamicProxyTest$IHello {
    
    private static final Method m0;
    private static final Method m1;
    private static final Method m2;
    private static final Method m3;
    
    public $Proxy0(final InvocationHandler h) {
        super(h);
    }
    
    // 지연 관계상 equals(), hashCode(), toString() 메서드는 생략했다.
    // 이 세 메서드의 내용은 위의 sayHello()와 매우 비슷하다.
    
    public final void sayHello() {
        try {
            super.h.invoke(this, $Proxy0.m3, null);
        } catch (Error | RuntimeException error) {
            throw;
        } catch (Throwable undeclaredThrowable) {
            throw new UndeclaredThrowableException(undeclaredThrowable);
        }
    }
    
    static {
        try {
            m0 = Class.forName("java.lang.Object")
                .getMethod("hashCode", (Class<?>[])new Class[0]);
            m1 = Class.forName("java.lang.Object")
                .getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object")
                .getMethod("toString", (Class<?>[])new Class[0]);
            m3 = Class.forName("org.fenixsoft.jvm.chapter9.DynamicProxyTest$IHello")
                .getMethod("sayHello", (Class<?>[])new Class[0]);
        } catch (NoSuchMethodException ex) {
            throw new NoSuchMethodError(ex.getMessage());
        } catch (ClassNotFoundException ex2) {
            throw new NoClassDefFoundError(ex2.getMessage());
        }
    }
}
```

- **간단한 구현 코드: 프락시 클래스의 구현 코드는 매우 간단함**
- **생성된 메서드**
    - Object 상속 `hashCode()`, `equals()`, `toString()` 메서드와 인터페이스 정의 각 메서드에 대응하는 구현 생성됨
- **`InvocationHandler::invoke()` 호출**
    - 메서드 구현 본문은 항상 `InvocationHandler` 객체의 `invoke()` 메서드 호출
    - **매개변수 차이**: 메서드별 차이점은 전달되는 매개변수와 메서드 객체가 다를 뿐
    - **실제 로직 실행**: 동적 프락시의 어떤 메서드가 호출되든 실제로는 `InvocationHandler::invoke()`에서 프락시 로직 실행
- **바이트코드 생성 과정:**
    - `generateProxyClass()` 메서드가 프락시 클래스 `$Proxy0.class`의 바이트코드를 생성하는 방법은 일반적인 클래스 파일 형식 명세에 맞춰 바이트코드구성  ****

## **9.2.4 백포트 도구: 자바의 타임머신**

- **신기술 적용의 어려움: 소프트웨어 회사 규모 커지고 레거시 기술 쌓이면 신기술 적용 또는 프레임워크 교체 어려움**
    - **기술 중심 → 제품 중심**: 회사의 중심이 '기술'에서 '제품'으로 이동하며 기술 선택 권한 감소
    - **안정성 유지**: 축적된 기존 코드 및 기술이 수익과 연결되므로 안정화된 팀은 기반 기술 변경에 신중함
- **IT 업계의 빠른 변화와 JDK 혁신:**
    - **신기술 등장**: IT 업계 빠르게 발전하며 새로운 기술 지속 등장
    - **JDK 메이저 릴리스**: JDK는 메이저 릴리스마다 다수 기술 혁신, 특히 자바 구문 변화 시 개발자 프로그래밍 습관에 큰 영향
- **주요 JDK 버전별 구문 개선 예시:**
    - **JDK 5**: 오토박싱, 제네릭, 애너테이션, 열거형, 가변 길이 매개 변수, 개선된 for 문(foreach)
    - **JDK 8**: 람다식, 스트림 API, 디폴트 메서드
    - **JDK 9~11**: 지역 변수 타입 추론
    - **JDK 12~17**: 텍스트 블록, `instanceof`의 패턴 매칭, `switch` 표현식, 레코드 클래스
    - **JDK 18~21**: 봉인된 클래스와 레코드 패턴, `switch` 문의 패턴 매칭
- **문법 개선의 '필수성'**
    - 문법적 지원 없던 시대에도 자바 프로그램 작성 가능했으나, 지금까지의 문법 개선은 거의 모두 '필수적'이었음
- **백포트 도구의 필요성: 기존 투자 보호 및 프로그램 구조 안정 유지를 위해 기술 지원 끊긴 이전 버전 JDK(예: JDK8) 사용 회사들 존재. 상위 버전 JDK코드를 하위 버전 JDK환경에 배포 가능하도록 다양한 백포트도구 등장**
    - **대표적인 백포트 도구**: 레트로트랜슬레이터(Retrotranslator), 레트로 람다(Retrolambda), 제이블(Jabel)
    - **레트로트랜슬레이터**: JDK5 컴파일 클래스 파일을 JDK1.3 또는 JDK1.4 배포 버전으로 변환. 오토박싱, 제네릭, 애너테이션, 열거형, 가변 길이 매개 변수, 개선된 for 문, 정적 임포트, 개선된 컬렉션, 동시성 패키지, 애너테이션 리플렉션등 지원
    - **레트로 람다**: JDK8의 람다식 및 try-resources 구문 등을 JDK5~7 사용 가능 형식으로 변환. 제한적 인터페이스 디폴트 메서드도 지원
    - **제이블**: JDK9~14 새로운 기능(예: switch 표현식, var)을 JDK8에서 구동 가능하게 변경
- **백포트 도구의 작동 방식 이해: 옛 버전 JDK에서 신 버전 기능 시뮬레이션 방법 이해를 위해 JDK업그레이드 시 제공되는 신기능을 다섯 범주로 분류 필요**
    1. **자바 클래스 라이브러리 개선**:  
        - **예시**: JDK1.2 컬렉션 클래스들, JDK5 동시성 패키지, JDK7 `java.lang.invoke` 패키지 등
        - **시뮬레이션 가능성**: 백포트도구가 완벽하게 시뮬레이션 가능한 유형
        - **구현 용이성**: 구현 상대적으로 쉬움
        - **과거 사례**: JDK5 동시성 패키지는 JDK5 등장 전부터 존재하던 API(dl.util.concurrent 패키지)를 표준 API로 흡수한 사례
        - **백포트 방법**: 독립적인 클래스 라이브러리 형태로 구현. 레트로트랜슬레이터는 동시성 패키지 대신 'Backport-util-concurrent.jar' 라이브러리를 별도 프로젝트로 제공
    2. **프런트엔드 컴파일러(javac) 수준의 개선**:  
        - **예시**: 오토박싱/언박싱(컴파일러가 `valueOf()` 호출 코드 자동 삽입), 가변 길이 매개 변수(자동으로 배열 변환), 제네릭 정보 소거(컴파일러가 형 변환 코드 삽입)
        - **정의**: 컴파일러 수준에서 기존 코드로 변환 가능한 구문 편의 문법
        - **시뮬레이션 가능성**: 백포트도구가 완벽하게 시뮬레이션 가능한 유형
        - **백포트 방법**: 레트로트랜슬레이터는 ASM 프레임워크 활용하여 바이트코드 직접 조작
        - **바이트코드 변화 없음**: 클래스 파일을 구성하는 바이트코드명령어 개수는 변하지 않으므로 JDK1.3이든 JDK5든 바이트코드로 표현 가능한 의미 범위는 같음
        - **버전 번호 및 메타데이터 수정**: 클래스 파일 버전 번호 변경만으로는 문제 해결 불가, 메타데이터 정보와 구문 지원 일부 내용 적절히 수정 필요
        - **열거형(enum) 예시**
            - JDK5에서 `enum` 키워드 추가되었으나, 클래스 파일 상수 풀 `CONSTANT_Class_info` 상수 의미 변화 없음
            - `CONSTANT_Enum_info`와 같은 새로운 상수 추가되지 않음
            - `enum` 키워드로 상수 정의는 `class` 키워드나 `interface` 키워드로 클래스와 인터페이스 정의와 실질적으로 같음. 컴파일러가 대신 수행
            - 바이트코드관점에서 열거형은 `java.lang.Enum` 상속 및 `values()`와 `valueOf()` 메서드 포함하는 일반 자바 클래스
            - **레트로트랜슬레이터의 열거형 처리**: 상위 클래스 `java.lang.Enum`을 자체 런타임 라이브러리 `net.sf.retrotranslator.runtime.java.lang.Enum_`으로 대체하고, 클래스 및 필드 접근 플래그 중 `ACC_ENUM` 플래그 삭제
            - **메서드 재생성**: 부모 클래스 변경으로 `values()`와 `valueOf()` 메서드도 다시 작성 필요
    3. **바이트코드 차원에서 지원이 필요한 변경**:  
        - **예시**: JDK7 추가 동적 언어 지원 기능 구현 시 가상 머신이 `invokedynamic`바이트코드명령어 지원 필요
        - **변경 사례의 희귀성**: 바이트코드집합 안정적으로 운영되므로 바이트코드수준 변경 사례 매우 드묾
        - **백포트 어려움**: 제삼 도구로는 완벽 백포트어렵거나 효율 크게 떨어짐
        - **레트로 람다의 람다식 시뮬레이션**: JDK8 람다식 시뮬레이션 예는 이 유형에 해당
        - `invokedynamic` 명령어: 자바는 람다 지원을 위해 `invokedynamic` 새로운 바이트코드명령어 사용
        - **필수적이지 않음**: `invokedynamic` 명령어는 효율 높이는 수단일 뿐 필수는 아님
        - **기존 명령어 활용 가능**: 이전에도 자바 가상 머신실행 다른 프로그래밍 언어에서 람다식 널리 사용되었으며, 효율 떨어져도 람다식은 기존 바이트코드명령어만으로 구현 가능
        - **레트로 람다의 구현 방식**: 최적화를 위해 기본적으로 몇 가지 익명 내부 클래스 생성. 무상태 람다식 대체 시 객체 반복 생성 방지를 위해 싱글턴 사용
        - **통합 개발 환경의 람다식 표시**: IntelliJ IDEA나 이클립스 같은 일부 자바 통합 개발 환경에는 이 과정을 반대로 수행하는 기능 포함, 낮은 버전 자바 코드 볼 때 익명 내부 클래스가 람다식으로 표시됨
    4. **JDK 구조 전반의 개선**:  
        - **예시**: JDK9 도입 자바 모듈 시스템은 자바 구조, 구문, 클래스 로딩및 링킹 처리 방식, 가상 머신에 이르기까지 광범위한 변경 필요
        - **백포트 어려움:** 어렵거나 효율 크게 떨어짐
    5. **가상 머신 내부 개선**:  
        - **예시**: JDK5 적용 자바 메모리 모델및 JDK7, 11, 12 도입 G1, 셰넌도어, ZGC 같은 컬렉터 변경은 개발자에게 직접 드러나지 않음
        - **백포트 어려움**: 어렵거나 효율 크게 떨어짐

## **9.3 실전: 원격 실행 기능 직접 구현하기**

### **문제 상황 및 일반적인 대처 방법**

- **흔히 겪는 문제 상황: 프로그램 유지 보수 시 서버에서 임시 코드 실행 방법 없어 문제 해결 어려운 경우 많음**
    - 특정 매개변수 값 확인 필요하나 화면/로그 출력 방법 없는 경우
    - 서비스 재시작으로 캐시를 비워야 하는 경우

### **9.3.1 목표**

> “서버에서 임시 코드를 실행한다”
> 
- **제품의 최종 요구 사항**
    - **JDK 호환성**: JVMTI와 같이 버전에 구애받지 않는 기능은 JDK1.4 이상의 주류 JDK에서 구동 가능해야 함
    - **독립성**: 원래 서버 프로그램 배포에 영향 주지 않으며 서드 파티 클래스 라이브러리 사용하지 않음
    - **비침해성**: 원래 프로그램 코드 변경 없으며 프로그램 동작에도 영향 주지 않음
    - **자바 언어 지원**: 임시 코드는 빈셸 스크립트나 자바스크립트 등에서 자바 객체 사용 불편하므로 자바 언어 직접 지원 필요
    - **자유로운 구현**: 특정 클래스에 의존하거나 특정 인터페이스 구현 불필요 해야 함
    - **라이브러리 참조 가능**: 임시 코드는 제한 없이 다른 클래스 라이브러리 참조 가능. 서버 프로그램 사용 가능한 클래스 및 인터페이스라면 임시 코드에서도 직접 참조 가능
    - **결과 수신**: 클라이언트는 임시 코드 실행 결과 수신 가능해야 함. 실행 결과에 프로그램 출력 정보 및 발생 예외 포함 가능

### **9.3.2 아이디어 구상**

- **해결해야 할 세 가지 문제:**
    - 서버에 제출된 자바 코드 컴파일
    - 컴파일된 자바 코드 실행
    - 실행 결과 수집
- **문제 해결 방안 구체화:**
    - **서버에 제출된 자바 코드 컴파일**:
        - **서버에서 컴파일**: JDK6부터 컴파일러 API사용 가능, `JAVA_HOME/lib/tools.jar` 내 `com.sun.tools.Javac.Main` 클래스로 자바 파일 컴파일 가능
            - **단점**: 특정 JDK에 의존하게 되며, 다른 업체 JDK에 배포 시 `tools.jar` 함께 배포 필요. JRockit과 J9 가상 머신에서 `tools.jar` 패키지 필수가 아니어서 모든 환경에서 제공 보장 불가
        - **클라이언트에서 컴파일**: 자바 코드를 클라이언트에서 컴파일 후 바이트코드를 서버에 전달하는 방법
            - **가정**: 일반적으로 클라이언트가 코드 컴파일 능력 있다고 가정해서는 안 됨. 컴파일에 필요한 도구와 라이브러리 있다고 가정해서도 안 됨
            - **이번 예시에서의 가정**: 자바 코드 작성 가능한 개발자 컴퓨터에서 클라이언트 수행되므로 필요한 환경 갖춰져 있다고 봄
    - **컴파일된 자바 코드 실행**:
        - **요구사항**
            - 클래스 반복적 제출, 수정, 실행 가능해야 함.
            - 제출된 클래스는 서버 측 다른 클래스 라이브러리 이용 가능해야 함. 제출된 '임시' 코드는 실행 후 언로드 및 필요시 재활용 가능해야 함
        - **방법**: 클래스 로더가 클래스 로드하여 클래스 객체 생성 후 리플렉션이용 메서드 호출
            - `main()` 메서드 호출: 어떤 인터페이스도 강제하지 않으므로 `main()` 메서드 호출 예정
        - **주의사항**: 단발성 실행 및 종료로 설계되지 않는 경우가 많으니 주의 필요
    - **실행 결과 수집**:
        - **표준 출력 및 오류 수집**: 표준 출력(`System.out`)과 표준 오류(`System.err`)에서 내보낸 정보 수집 예정
        - `System.setOut()` / `System.setErr()` 문제점: 가상 머신전체에서 공유하는 자원이므로 이 메서드 이용 시 원래 프로그램에도 영향 주어 다른 스레드 표준 출력 정보까지 수집됨
        - **해결 방안**: 실행될 클래스 내 `System.out` 심벌 참조를 우리가 준비한 `PrintStream` 심벌 참조로 변경하는 방법 활용

### **9.3.3 구현**

- **도우미 클래스: 총 4개의 도우미 클래스 사용**
    - `HotSwapClassLoader` 클래스
        
        ```java
        public class HotSwapClassLoader extends ClassLoader {
        
            public HotSwapClassLoader() {
                super(HotSwapClassLoader.class.getClassLoader());
            }
        
            public Class loadByte(byte[] classByte) {
                return defineClass(null, classByte, 0, classByte.length);
            }
        
        }
        ```
        
        - ‘같은 클래스의 여러 코드를 여러 번 로드할 수 있다’ 조건 구현에 사용
        - `loadByte()` 메서드
            - `ClassLoader`에서 `protected` 로 정의된 `defineClass()` 를 외부로 노출하는 역할
    - `ClassModifier` 및 `ByteUtils` 클래스
        
        ```java
        public class ClassModifier {
        
            /**
             * 클래스 파일에서 상수 풀의 시작 오프셋
             */
            private static final int CONSTANT_POOL_COUNT_INDEX = 8;
        
            /**
             * CONSTANT_Utf8_info 상수의 태그 플래그
             */
            private static final int CONSTANT_Utf8_info = 1;
        
            /**
             * 상수 풀에서 CONSTANT_Utf8_info 타입 상수를 제외한 11가지 상수가 차지하는 길이
             * (CONSTANT_Utf8_info는 고정 길이가 아님)
             */
            private static final int[] CONSTANT_ITEM_LENGTH = {-1, -1, -1, 5, 5, 9, 9, 3, 3, 5, 5, 5, 5};
        
            private static final int u1 = 1;
            private static final int u2 = 2;
        
            private byte[] classByte;
        
            public ClassModifier(byte[] classByte) {
                this.classByte = classByte;
            }
        
            /**
             * 상수 풀에서 CONSTANT_Utf8_info 상수의 내용을 수정한다.
             *
             * @param oldStr 수정 전의 문자열
             * @param newStr 수정된 문자열
             * @return 수정된 결과
             */
            public byte[] modifyUTF8Constant(String oldStr, String newStr) {
                int cpc = getConstantPoolCount();
                int offset = CONSTANT_POOL_COUNT_INDEX + u2;
                for (int i = 0; i < cpc; i++) {
                    int tag = ByteUtils.bytes2Int(classByte, offset, u1);
                    if (tag == CONSTANT_Utf8_info) {
                        int len = ByteUtils.bytes2Int(classByte, offset + u1, u2);
                        offset += (u1 + u2);
                        String str = ByteUtils.bytes2String(classByte, offset, len);
                        if (str.equalsIgnoreCase(oldStr)) {
                            byte[] strBytes = ByteUtils.string2Bytes(newStr);
                            byte[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);
                            classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);
                            classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);
                            return classByte;
                        } else {
                            offset += len;
                        }
                    } else {
                        offset += CONSTANT_ITEM_LENGTH[tag];
                    }
                }
                return classByte;
            }
        
            /**
             * 상수 풀 안의 상수 개수 반환한다.
             *
             * @return 상수 풀 내의 상수 개수
             */
            public int getConstantPoolCount() {
                return ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);
            }
        }
        ```
        
        ```java
        public class ByteUtils {
        
            public static int bytes2Int(byte[] b, int start, int len) {
                int sum = 0;
                int end = start + len;
                for (int i = start; i < end; i++) {
                    int n = ((int) b[i]) & 0xff;
                    n <<= (--len) * 8;
                    sum = n + sum;
                }
                return sum;
            }
        
            public static byte[] int2Bytes(int value, int len) {
                byte[] b = new byte[len];
                for (int i = 0; i < len; i++) {
                    b[len - i - 1] = (byte) ((value >> 8 * i) & 0xff);
                }
                return b;
            }
        
            public static String bytes2String(byte[] b, int start, int len) {
                return new String(b, start, len);
            }
        
            public static byte[] string2Bytes(String str) {
                return str.getBytes();
            }
        
            public static byte[] bytesReplace(byte[] originalBytes, int offset, int len, byte[] replaceBytes) {
                byte[] newBytes = new byte[originalBytes.length + (replaceBytes.length - len)];
                System.arraycopy(originalBytes, 0, newBytes, 0, offset);
                System.arraycopy(replaceBytes, 0, newBytes, offset, replaceBytes.length);
                System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);
                return newBytes;
            }
        }
        ```
        
        - `ClassModifier` 목적
            - `byte[]` 배열을 String으로 변환하며, `ByteUtils`가 수행하는 데이터 교체 작업을 캡슐화
            - `ClassModifier`가 처리한 `byte[]` 배열은 클래스로 로딩하기 위해 `HotSwapClassLoader.loadByte()` 메서드로 전달
            - `byte[]` 배열의 심벌 참조를 `HackSystem` 클래스로 직접 참조해 컴파일한 클래스와 정확히 일치하는 모습으로 대체
            - 클라이언트가 임시 실행 코드 작성 시 특정 클래스에 의존하지 않도록 하고, 서버에서 표준 출력 변경 시 프로그램 다른 출력에 까지 영향 주는 일 방지
        - `ClassModifier` 상수들
            - `CONSTANT_POOL_COUNT_INDEX`: 클래스 파일에서 상수 풀의 시작 오프셋
            - `CONSTANT_Utf8_info`: 상수 풀에서 `CONSTANT_Utf8_info` 상수의 태그 플래그
            - `CONSTANT_ITEM_LENGTH`: `CONSTANT_Utf8_info` 타입을 제외한 11가지 상수가 차지하는 고정 길이 배열
        - `modifyUTF8Constant(String oldStr, String newStr)` 메서드: `CONSTANT_Utf8_info` 상수 풀에서 특정 문자열(`oldStr`) 내용을 새로운 문자열(`newStr`)로 수정
    - `HackSystem` 클래스 (코드 9-6)
        
        ```java
        public class HackSystem {
            public final static InputStream in = System.in;
            private static ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            public final static PrintStream out = new PrintStream(buffer);
            public final static PrintStream err = out;
        
            public static String getBufferString() {
                return buffer.toString();
            }
        
            public static void clearBuffer() {
                buffer.reset();
            }
        
            public static void setSecurityManager(final SecurityManager s) {
                System.setSecurityManager(s);
            }
        
            public static SecurityManager getSecurityManager() {
                return System.getSecurityManager();
            }
        
            public static long currentTimeMillis() {
                return System.currentTimeMillis();
            }
        
            public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) {
                System.arraycopy(src, srcPos, dest, destPos, length);
            }
        
            public static int identityHashCode(Object x) {
                return System.identityHashCode(x);
            }
        
            // 그 외 메서드들의 이름은 모두 java.lang.System의 메서드와 같음
        }
        ```
        
        - `java.lang.System`을 대체하는 클래스
        - System 클래스와의 차이점
            - 기본 `System`에서 정적 변수 `out`과 `err`의 출력 대상이 `ByteArrayOutputStream` 객체로 변경되는 부분 등
            - 나머지 모든 메서드는 `System` 클래스 메서드 그대로 가져옴
    - `JavaclassExecuter` 클래스 (코드 9-7)
        
        ```java
        public class JavaclassExecuter {
            public static String execute(byte[] classByte) {
                HackSystem.clearBuffer();
                ClassModifier cm = new ClassModifier(classByte);
                byte[] modiBytes = cm.modifyUTF8Constant("java/lang/System", "org/fenixsoft/classloading/execute/HackSystem");
                HotSwapClassLoader loader = new HotSwapClassLoader();
                Class clazz = loader.loadByte(modiBytes);
                try {
                    Method method = clazz.getMethod("main", new Class[]{String[].class});
                    method.invoke(null, new String[]{null});
                } catch (Throwable e) {
                    e.printStackTrace(HackSystem.out);
                }
                return HackSystem.getBufferString();
            }
        }
        ```
        
        - 앞에서 작성한 도우미 클래스들을 활용하여 클래스를 로딩하는 클래스
            - `System` 심벌 참조를 클래스 파일 포맷 준수 `byte[]` 배열로 교체
            - `HotSwapClassLoader` 사용하여 로드하고 클래스 객체 생성
            - 리플렉션으로 클래스의 `main()` 메서드 호출
        - `execute()` 호출 시마다 클래스 로더 인스턴스 새로 생성되므로 같은 클래스 반복 로드 가능
        - 이 과정에서 예외 발생 시 예외 정보를 `HackSystem.out`으로 출력
        - 버퍼에 담긴 정보(실행 결과) 반환

### **9.3.4 검증**
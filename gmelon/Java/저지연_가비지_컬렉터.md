> JVM 밑바닥까지 파헤치기 3.6 - 3.8 절에 대한 내용입니다.

# 3.6 저지연 가비지 컬렉터

## 개요

### 삼각 정리

- 가비지 컬렉터에서의 `완벽` 이란?
    - 도달하기는 어렵지만, 객관적으로 기술할 수는 있다
- 가비지 컬렉터를 측정하는 중요한 지표 3가지 → `삼각 정리 (impossible trinity)`
    - 처리량
    - **지연 시간 → 중요성이 점점 커지고 있음**
    - 메모리 사용량
    
    <img width="504" height="354" alt="Image" src="https://github.com/user-attachments/assets/65a6e21c-aa8c-43d2-a28a-270044277690" />
    
- HW 가 발전하며 메모리 사용량이나 성능은 달성하기 쉬워짐
- 하지만, 지연시간은 다름
    - e.g. 메모리를 늘리면 GC 대상이 늘어나므로 지연 시간도 함께 늘어남

### 다양한 컬렉터의 동시성 비교

<img width="625" height="422" alt="Image" src="https://github.com/user-attachments/assets/1283bae6-bde4-4354-a4c8-181136b42a42" />

- CMS 이전
    - 모든 과정이 STW
- CMS, G1
    - 증분 업데이트, 시작 단계 스냅숏 기술을 통해 표시 단계를 동시에 수행
    - 하지만,
        - CMS (마크-스윕) → 파편화가 심해져 STW 를 피할 수 없음
        - G1 (마크-카피&컴팩트) → 리전 단위로 복사하여 일시 정지가 짧긴 하지만 여전히 동시 수행은 불가능
- 세년도어, ZGC
    - 지연 시간을 단축하는 것에 초점이 맞춰진 가비지 컬렉터
    - 힙이 아무리 커져도 가비지 컬렉션으로 인한 일시 정지는 최대 10ms 를 넘지 않도록 설계됨

## 3.6.1 셰넌도어

### 개요

- 오라클의 가상 머신 개발 팀이 주도하지 않은 첫 번째 핫스팟 가비지 컬렉터
- 셰넌도어 프로젝트의 목표
    - 힙 크기와 상관없이 GC 일시 정지를 10ms 이내로 묶어 두는 것
    - 이를 위해 표시 단계는 물론, 객체 회수 후 마무리 작업까지 사용자 쓰레드와 함께 수행해야 했음
- G1 와 힙 레이아웃이 비슷하고, 심지어 코드 일부를 직접 공유
    - e.g. G1 은 셰넌도어의 코드를 통합한 덕분에, 동시 실패의 탈출구인 전체 GC 를 멀티 쓰레드로 처리할 수 있게 됨 ([JEP 307](https://openjdk.org/jeps/307))

### 셰넌도어의 G1 대비 개선 사항

1. 동시 모으기 지원
    1. G1 역시 여러 쓰레드를 이용해 병렬 수행하지만, 사용자 쓰레드와 동시 수행은 불가능
2. 세대 단위 컬렉션 사용 X
    1. 세대 이론이 가치가 없어진 것은 아님
    2. 구현 복잡도를 고려해 우선순위가 밀림 (추후 지원 예정)
3. `기억 집합` 대신 `연결 행렬`을 사용해 리전 간 참조 관계를 기록
    1. 리전 N에 리전 M을 가리키는 객체가 있다면 표의 N행 M열에 표시
    2. 다음 회수 때 다시 표를 참고하여 리전간 참조를 포함하는 리전들을 알아냄
    
    <img width="565" height="394" alt="Image" src="https://github.com/user-attachments/assets/1ec96ff4-5b47-4f5e-ad94-2d1b0286357f" />
    

### [동작 방식](https://wiki.openjdk.org/display/shenandoah)

1. 최초 표시 (G1 처럼)
    1. 가장 먼저 GC 루트에서 직접 참조하는 객체들에 표시
    2. 여전히 STW지만, 매우 짧은 일시 정지 시간 (힙 크기에 관계없이 GC 루트 수에만 영향 받기 때문)
2. **동시 표시 (G1 처럼)**
    1. 객체 그래프를 타고 도달 가능한 모든 객체 표시
    2. 사용자 쓰레드와 동시 수행
    3. 수행 시간은 살아있는 객체 수와 객체 그래프의 복잡도와 연관
3. 최종 표시 (G1 처럼)
    1. 보류 중인 모든 표시 완료, GC 루트 집합을 다시 스캔
    2. 회수 가치가 가장 큰 리전들을 추려 회수 집합 생성
    3. 짧지만 STW
4. 동시 청소
    1. 살아있는 객체가 하나도 없는 리전 청소
5. **동시 이주**
    1. 셰넌도어를 핫스팟의 다른 컬렉터들과 구분해주는 핵심적 차이
    2. **사용자 쓰레드와 동시에**, **회수 집합** 안에 살아있는 객체들을 다른 빈 리전으로 복사
        1. 객체를 이동하는 동안 사용자 쓰레드가 해당 객체를 읽고 쓸 수 있다는 문제가 있음
        2. 이동 전 객체 참조를 이동 후로 변경해주어야 하고, 셰넌도어를 이 문제를 해결하기 위해 읽기 장벽과 포워딩 포인터를 이용
6. 최초 참조 갱신
    1. 객체 복사 이후, 힙에서 이전 객체를 가리키는 모든 참조를 복사 후의 새로운 주소로 수정 (참조 갱신)
    2. 초기 단계에서는, 그저 동시 이주 단계의 모든 GC 쓰레드와 사용자 쓰레드가 이주를 끝마쳤음을 보장
    3. 아주 짧은 STW 발생
7. **동시 참조 갱신**
    1. 참조 갱신을 **실제로** 시작, 사용자 쓰레드와 동시에 수행
    2. 물리 메모리 주소의 순서대로 참조 타입을 선형 검색하여 이전 값을 새로운 값으로 수정
8. 최종 참조 갱신
    1. 힙 참조 갱신 이후, GC 루트 집합의 참조를 갱신하는 단계
    2. 마지막 STW, GC 루트 개수에 비례한 STW 시간 발생
9. 동시 청소
    1. 이주 & 참조 갱신이 완료되면 **회수 집합**의 모든 리전에는 살아있는 객체가 남지 않게 됨
    2. 따라서 동시 청소를 다시 수행하여, 새로운 객체를 할당할 공간 확보

---

<img width="697" height="350" alt="Image" src="https://github.com/user-attachments/assets/5be702ec-ed69-458c-88a1-6da7eee2a4b2" />

1. 동시 표시 단계에서 회수할 객체를 찾는 방법
2. 동시 이주 단계에서 살아있는 객체를 옮기는 방법
3. 동시 참조 갱신 단계에서 생존한 객체들의 참조를 모두 수정하는 방법
4. (마지막) 최종적으로 회수 집합에 살아있는 객체가 하나도 남지 않은 모습

### 포워딩 포인터

> 동시 이주를 가능하게 하는 핵심 개념
→ 즉, 객체 이동과 사용자 프로그램을 동시에 수행하는 방법

- 기존 방식
    - 이동될 객체의 원래 메모리에 ‘메모리 보호 트랩’ 을 설정
    - 기존 메모리 공간에 접근하려 하면 트랩이 발동해 예외 처리기가 수행되어 새 객체를 사용하도록 하는 방식
    - 유저 ↔ 커널 전환이 필요해 비용이 큰 해법
- 브룩스가 제안한 방식 (포위딩 포인터)
    - 객체 레이아웃 구조 상단에 가장 최신의 객체를 가리키는 `참조 필드` 추가
    - 동시 이주가 아닐 경우, 객체 자신을 가리킴
    - 읽기 시점에, 객체에 우회하여 접근하는 오버헤드가 발생하긴 함
    
    <img width="647" height="433" alt="Image" src="https://github.com/user-attachments/assets/9a6cf689-3924-4daf-a76c-9990c1277434" />
    
- 문제점 1: 쓰레드 경쟁 가능성
    - 읽기만 발생하면 문제 X
    - 쓰기가 발생한다면 아래와 같이 사용자 쓰레드가 이전 객체를 변경하는 케이스 가능
        
        ```sql
        1. GC 쓰레드가 객체의 복사본을 만듦
        2. 사용자 쓰레드가 객체의 필드를 덮어씀
        3. GC 쓰레드가 옛 객체의 포워딩 포인터 값을 복사본의 주소로 수정
        ```
        
    - 이를 막기 위해 `포워딩 포인터에 접근하는 작업`이 원자적으로 수행되어야 함
    - 셰넌도어는 CAS 연산을 통해 이를 해결 (GC 쓰레드 또는 사용자 쓰레드 중 동시에 하나만 접근 가능)
- 문제점 2: 실행 빈도
    - `문제점 1` 을 해결하기 위해 객체 접근 시마다 `읽기 장벽` 이 필요
    - 객체 접근은 매우 빈번하게 발생 하므로, `읽기 장벽` 의 오버헤드를 줄이는 것이 중요함

### [로드 참조 장벽](https://developers.redhat.com/blog/2019/06/27/shenandoah-gc-in-jdk-13-part-1-load-reference-barriers)

- 읽기 장벽으로 인한 성능 오버헤드가 심했음
    - JDK 13 부터 `로드 참조 장벽`을 이용해 이를 개선
- 참조 타입의 데이터를 읽거나 쓸 때만 장벽이 동작
    - 즉, 원시 타입 관련 작업, 객체 비교, 객체 락 등의 시나리오에서는 읽기 장벽이 불필요하여 오버헤드를 상당히 줄일 수 있음
- https://stackoverflow.com/questions/63975139/shenandoah-garbage-collector-load-reference-barriers
    - 수행하고 싶은 유저 코드
        
        ```java
        public void access(Holder holder){
             User user = holder.user;
             for(;;){ // some loop here
                 int zip = user.zip;
                 System.out.println(zip);
        
                 user.age = // some value taken from the loop for example
             }
        }
        ```
        
    - 기존 방식
        
        ```java
        public void access(Holder holder){
          User user = RB(holder).user;  
          for(;;){ // some loop here
              int zip = RB(user).zip;
              System.out.println(zip);
        
              WB(user).age = // some value taken from the loop for example
          }
        }
        ```
        
    - 로드 참조 장벽 도입 이후
        - 쓰기가 발생하는 곳에 장벽을 사용하는 대신,
        - 처음에 로드된 객체가 확실히 `to-space` 에서 로드되었는지 확인
        - 덕분에 로드된 참조 객체 내부의 원시 필드는, 마음 놓고 사용할 수 있음
        
        ```java
        public void access(Holder holder){
            User user = LRB(holder).user;  
            for(;;){ // some loop here
                int zip = user.zip;
                System.out.println(zip);
        
                user.age = // some value taken from the loop for example
            }
        }
        ```
        

### 포워딩 포인터를 객체 헤더에 통합

- 객체 헤더 > 마크 워드 중 마지막 2비트를 `락 플래그` 라고 함
    - 이 값이 `0b11` 일 떄는 용도가 정의되어 있지 않음을 활용해, 마크 워드를 포워딩 포인터로 활용
    
    <img width="640" height="229" alt="Image" src="https://github.com/user-attachments/assets/f4db462b-46d4-472e-b554-3e653485b6f6" />
    
- 로드 참조 장벽 덕분에, 읽기 장벽 없이도 이를 구현할 수 있게 됨
- 기존 포워딩 포인터 때문에 다른 GC에 비해 추가로 사용되던 5~10% 의 메모리를 절약할 수 있게 됨
    1. 같은 공간에 더 많은 객체를 담을 수 있어서, GC 횟수가 줄어듦
    2. CPU 캐시에 더 많은 객체를 담을 수 있어, 적중률이 높아짐
    3. 다른 GC 와 객체 할당 코드를 공유할 수 있어서, 구현 로직이 단순해짐

### [스택 워터마크](https://openjdk.org/jeps/376)를 활용한 쓰레드 스택 동시 처리

> JDK 17 에 반영된 개선 사항

- 쓰레드는 스택을 가지고, 스택은 스택 프레임들로 채워지고, 프레임은 다시 현재 메서드를 실행하는데 필요한 지역 변수, 모니터 등 정보를 갖는다
    - GC 관점에서는 힙 객체들의 참조가 여기 스택에 저장되어 있다
- GC 가 시작되면 모든 쓰레드의 스택을 스캔하여 참조들을 `표시 큐` 에 담음
    - 이 과정에서, 사용자 쓰레드들이 스택을 계속 변경하지 못하도록 `안전 지점`에서 진행
    - → 시간이 소요됨 → 이걸 어떻게 동시에 수행할 수 있을까?
- 쓰레드 스택 중 변화가 생기는 부분은 `최상위 스택 프레임` 뿐
    - 현재 실행 중인 메서드이기 때문
    - 나머지 스택 프레임은 사용자 쓰레드가 실행되는 도중에도 얼마든지 GC 스캔이 가능
    
    <img width="613" height="343" alt="Image" src="https://github.com/user-attachments/assets/a451bc5a-7abb-46ea-973c-72fd714b77a2" />
    
- 최초 표시
    - 모든 쓰레드의 최상위 프레임에 스택 워터마크 설정
    - 모든 프레임이 동시 스캔에는 안전 O, 동시 실행에는 안전 X
- 최상위 스택 프레임을 파괴할 때 마다 사용자 쓰레드의 동작 과정
    1. 워터마크를 한 칸 낮춤
    2. GC 쓰레드가 워터마크 위로는 스캔하지 못하도록 막음
    3. `1` 의 결과로 워터마크 위로 떠오른 스택 프레임을 스캔
- [ ]  이러한 방식으로, 최초 표시 때 일시 정지 후 진행하던 모든 작업을 사용자 쓰레드와 동시에 수행할 수 있게 됨

### 성능

- 일래스틱 서치를 써서 위키백과 데이터 200GB를 인덱싱하는 실험
    - 일시 정지 시간은 극적으로 줄였지만 '최장 정지 시간을 10밀리초 이내로 제어하겠다'는 목표는 실패
    - 또한 처리량이 크게 저하되어 테스트한 컬렉터 중 실행 시간이 가장 김

<img width="671" height="217" alt="Image" src="https://github.com/user-attachments/assets/8e8fabbb-360d-4322-ba7b-85160fcdea18" />

- 반면 스택 워터마크까지 적용한 JDK 17 버전 셰넌도어는,
    - 평균 일시 정지 시간을 1ms 이하로 줄이는데 성공
    
    <img width="445" height="205" alt="Image" src="https://github.com/user-attachments/assets/2160b076-fb50-4dc9-ae7a-d364a7b50593" />
    

## 3.6.2 ZGC

### 개요

- 오라클이 개발한 저지연 가비지 컬렉터
- JDK 15에서 정식 버전 탑재, JDK 21 부터는 세대 구분 ZGC 추가
- 목표는 셰넌도어와 흡사
    - `처리량에 미치는 영향을 최소화하면서, 일시 정지 시간을 10ms 안쪽으로 줄이고 싶다`
- 구현 방향은 사뭇 다름
    - 세대 구분 없이 리전 기반 메모리 레이아웃을 사용
    - 낮은 지연 시간을 최우선 목표로 하며
    - 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 포인터, 메모리 다중 매핑 기술을 이용

### 리전 기반 메모리 레이아웃

<img width="423" height="345" alt="Image" src="https://github.com/user-attachments/assets/1dfa364f-7021-494c-a3f7-5d86934e0cc0" />

- 셰넌도어와 G1 처럼 리전으로 메모리를 나누지만 약간의 차이점이 존재
- 리전이 동적으로 생성/파괴됨
- 크기도 동작으로 달라짐
    1. 소: 2MB 고정, 256KB 미만 작은 객체 포함
    2. 중: 32MB 고정, 256KB ~ 4MB 미만 객체 포함
    3. 대: 2MB 배수의 동적 크기, 4MB 이상 객체 단 하나만 담음

### 병렬 모으기 & 컬러 포인터

- 셰년도어는 동시 이주를 지원하기 위해 포워딩 포인터와 읽기 장벽을 사용
    - ZGC 도 읽기 장벽을 사용하지만, 더 복잡 & 정교한 방식으로 사용
- 컬렉터 별 객체에 대한 추가 데이터 저장 방식
    - 시리얼: 객체 헤더에 직접 표시
    - G1, 셰넌도어, …: 힙 메모리의 1/64 크기의 비트맵과 같이 객체와 독립된 자료 구조에 표시
    - **ZGC: 컬러 포인터 (객체를 가리키는 포인터에 직접 표시) 사용**
- 컬러포인터는 포인터 자체에 소량의 추가 정보를 직접 저장하는 기술
    - 어떻게 하면 더 많은 정보를 담을 수 있을까?
- 64비트 시스템은 HW/OS 제약 상 47비트 가상 주소 공간, 46비트 물리 주소 공간을 갖는다
    - ZGC 의 컬러 포인터는 주소 공간을 44비트까지로 제한하고, 상위 4비트를 4가지 플래그 정보 저장에 이용
        
        <img width="626" height="221" alt="Image" src="https://github.com/user-attachments/assets/049ce02f-b414-454a-9b3b-16764451a7d5" />
        
- 단점
    - 메모리 용량 제한
    - 32비트 플랫폼에서는 사용 불가
    - 압축 포인터 사용 불가
- 이점
    1. 한 리전 안의 생존 객체들이 이동하면 즉시 해당 리전을 재활용할 수 있음
        1. 즉, 전체 힙에서 해당 리전으로의 참조들을 전부 수정할 때까지 기다릴 필요가 없음 **(자가 치유)**
        2. 셰넌도어는 참조 갱신 단계가 끝나기 전에는 회수 중인 리전 재활용 불가
    2. GC 과정에서 메모리 장벽 수를 크게 줄일 수 있음
        1. 쓰기 장벽은 주로 객체 참조를 변경하기 위해 사용
        2. 이 정보를 포인터 자체에 두기 때문에 일부 기록 작업이 불필요해짐
        3. ZGC 는 쓰기 장벽 없이 읽기 장벽만 사용
            1. 이는 컬러 포인터 + 세대 구분 없는 ZGC 의 특정 덕분
    3. 컬러 포인터를 확장 가능한 저장 구조로 사용 가능
- 구현 상 기술적 이슈
    - JVM이 컬러 포인터에서 재정의한 포인터의 의미를 OS 에서 이해할 수 있도록 변환해야 함
    - x86-64용 리눅스에서 ZGC는 서로 다른 여러 가상 메모리 주소를 동일한 물리 메모리 주소로 매핑하기 위해 `다중 매핑` 을 이용
    - 다중 매핑을 거진 이후에는, 컬러 포인터 역시 일반적인 주소 지정에 사용할 수 있음
    
    <img width="644" height="307" alt="Image" src="https://github.com/user-attachments/assets/547c3ada-d06d-42b9-b510-c45419d074e8" />
    

### 동작 방식

<img width="649" height="194" alt="Image" src="https://github.com/user-attachments/assets/6229e82c-9bd3-42da-ab0b-1bf40d15b9d2" />

1. 동시 표시
    1. G1, 셰년도어처럼 동시 표시는 객체 그래프를 탐색하며 도달 가능성을 분석하는 단계
    - [ ]  G1, 셰년도어와 달리 객체 아니라 포인터에서 이뤄짐
        1. (컬러 포인터의 Marked0, Marked1 플래그가 이 단계에서 갱신)
2. 동시 재배치 준비
    1. 청소해야 할 리전들을 선정하여 재배치 집합 (relocation set) 생성
    2. **G1 회수 집합 ↔ ZGC 재배치 집합**
        1. ZGC 는 GC 마다 모든 리전을 스캔
        2. 따라서 G1 과 달리, 재배치 집합은 리전 안의 생존 객체들을 다른 리전으로 복사한 후 리전 자체를 회수할지 여부만 결정
        3. `1` 의 표시 대상이 힙 전체이므로 재배치 집합에 포함되지 않은 리전들도 회수 대상이 될 수 있음
3. **동시 재배치**
    1. 재비치 집합 안의 생존 객체들을 새로운 리전으로 복사
    2. 자가치유
        1. 사용자 쓰레드가 재배치 집합에 포함된 객체에 동시에 접근하려 들면, 미리 설정해둔 메모리 장벽이 끼어들어, 즉시 해당 리전의 포워드 테이블에 기록된 정보를 보고 새로운 객체로 포워드
        2. 동시에 해당 참조의 값도 새로운 객체를 직접 가리키도록 갱신
        3. 장점
            1. 옛 객체에 처음 접근할 때만 포워드가 발생
            2. 재배치 집합에 속한 생존 객체들의 복사가 끝나는 즉시 해당 리전을 재활용할 수 있음 (사용하는 순간 포워드 테이블을 참조하여 자가 치유될 것이기 때문)
4. 동시 재매핑
    1. 힙 전체에서 재배치 집합에 있는 옛 객체들을 향하는 참조 전부를 갱신
    2. 자가 치유 되기 때문에, 급한 작업은 아님
    3. 이 작업이 완료되면 포워드 테이블을 삭제할 수 있다

### 다른 컬렉터들과의 비교

- 타 GC 에서 사용하는 `기억 집합`은 메모리 공간을 상당히 차지
- `쓰기 장벽` 역시 사용자 쓰레드 성능에 영향을 줌
- 반면, ZGC 는 `기억 집합`, `쓰기 장벽`을 사용하지 않는다
    - 기억 집합 X → 매번 모든 힙을 탐색하기 때문
    - 쓰기 장벽 X → 세대 간 구분이 없어 카드 테이블이 불필요하기 때문
- 대신, ZGC 는 객체 할당 속도에 제한이 생김
    - `동시 표시` 단계가 진행 중일 때 객체가 아주 빠르게 생성되면,
    - 현 회수 단계에서는 다 표시하기 어려워서 대부분 살아남게 된다
    - 이로 인해 `부유 쓰레기` 가 많아지고, 이는 결국 STW 를 초래
    - 이 문제의 근본적인 해결책은 ZGC 의 세대를 구분하여 새로운 객체가 속하는 영역에 대한 GC 를 더 자주/빠르게 수행하는 것

### 성능 비교

- ZGC 의 최우선 목표는 일시 정지 시간 단축

<img width="684" height="907" alt="Image" src="https://github.com/user-attachments/assets/778c9691-c3fe-4fef-b1f3-4e0675d7a391" />

<img width="648" height="412" alt="Image" src="https://github.com/user-attachments/assets/5d69f13a-5fbc-4327-8c7c-2cce82269edf" />

## 3.6.3 세대 구분 ZGC

### 개요

- ZGC 에 `세대 구분` 개념을 도입
- 가장 큰 장점은, 수명이 짧은 젊은 객체들을 더 자주 회수한 다는 것
    - 기존 ZGC 는 매번 모든 세대의 객체를 대상으로 회수 작업을 진행해야 함
    - 객체가 생성되는 속도가 ZGC 의 회수 속도보다 빠르면 문제가 될 수 있음
- 초기 ZGC, 셰년도어에서는 구현 복잡도 이슈로 인해 세대 구분이 없음
- JDK 21 기준, 세대 구분 ZGC 는 여전히 옵션을 켜주어야 적용됨
    - 앞으로는, 대체될 것

### 다중 매핑 메모리 제거

> 읽기 장벽의 부하를 줄이기 위한 기술

- 기존 ZGC 는 다중 매핑으로 인해 동일한 힙 메모리를 세 개의 독립된 가상 주소로 매핑
    - 메모리 사용량을 확인하면 실제보다 3개 가량 높게 측정됨
- 세대 구분 ZGC 는 읽기 장벽과 쓰기 장벽의 코드를 명확히 구분
    - 쓰기 장벽에서 포워딩을 처리하므로, 다중 매핑이 불필요
    - 사용자 관점: 덕분에 정확한 메모리 사용량 측정 가능
    - GC 관점: 컬러 포인트에서 다중 매핑 관련 메타데이터 비트들이 제거되니, 확보된 비트를 다른 용도로 활용할 수 있음

### 이중 버퍼를 이용한 기억 집합 관리

- 일반적으로 기업 집합 > 카드 테이블의 한 바이트는 힙의 512 바이트에 대응
    - 구세대 → 신세대 포인터를 찾으려는 GC 는 512 바이트 모두를 확인해야 함
- 세대 구분 ZGC 는 비트맵을 이용, 객체 필드의 위치를 정확하게 기록
    - 비트맵 비트 하나가 객체 필드 주소 하나를 표현
        1. 메모리 슬롯 정렬
            - JVM 힙 내 모든 객체 참조(포인터)는 8바이트(또는 포인터 크기) 단위로 정렬됨
            - 정렬 덕분에 모든 가능한 참조 위치가 균일한 간격(Granularity)을 가짐
        2. 비트맵 인덱스 ↔ 주소 매핑
            - 힙을 Granularity 크기만큼 분할한 슬롯 N개마다 1비트씩 할당
            - 비트맵 배열에서 i번째 비트가 설정되었다면,
                
                주소 = (i × Granularity) + RegionBase 방식으로 실제 객체 필드 주소 계산 가능
                
        3. 영역 단위(Region) 관리
            - 힙을 고정 크기 Region으로 나누고, 각 Region마다 별도 비트맵 유지
            - RegionBase만 알면 비트맵 인덱스만으로 해당 Region 내 절대 주소 복원
    - 구세대 리전이 한 쌍의 기업 집합 비트맵 보유
    - 비트맵 하나는 사용자 쓰레드 쓰기 장벽에서 수정, 그 읽기 전용 복사본은 GC 쓰레드가 참고
    - 마이너 GC 가 시작될 때 마다 두 비트맵이 원자적으로 교환되어, 사용자 / GC 쓰레드는 서로를 신경쓰지 않고 일을 진행할 수 있음

### 밀집도 기반 리전 처리

- 최근에 할당된 리전이면 더 많은 객체가 살아있을 가능성이 큼
- 세대 구분 ZGC 는 어느 리전부터 회수해야 할지 정하기 위해, 신세대 리전들의 밀집도를 분석
    - 회수 대상으로 선택되지 않은 리전은 그대로 나이를 먹어 생존자 리전이 되거나, (다음 회수 대상이 될 가능성 커짐)
    - 더 먹으면 구세대 리전으로 승격
- 이처럼 리전을 그대로 둔 채 노화시키는 방식으로, 신세대 리전들을 회수하는 비용을 줄일 수 있음

### 거대 객체 처리

- 세대 구분 ZGC 는 거대 객체를 구세대로 복사하는 비용이 발생하지 않음
- `밀집도 기반 리전 처리` 를 통해 그대로 노화시킬 수 있기 때문 (그대로 해당 리전을 구세대로 승격)

# 3.7 적합한 가비지 컬렉터 선택하기

- 가장 진보한 컬렉터를 선택한다고 해서 모든 시나리오에서 최상의 성능을 내는 건 불가능
- 주어진 조건을 잘 확인하고 필요에 맞게 선택해야 함

## 3.7.1 엡실론 컬렉터

### 개요

- 가비지 컬렉션을 전혀 하지 않는 컬렉터
- 사실 ‘가비지 컬렉터’ 는 가비지 컬렉팅만 하는게 아님
    - 힙 관리, 레이아웃
    - 객체 할당
    - 인터프리터-컴파일러-모니터링 서브시스템 연동
    - … 등의 작업을 수행
    - 이 중 `힙 관리, 객체 할당` 은 수행해야 JVM 동작 가능

### 사용 범위

- 엡실론은 가비지 컬렉터용 통합 인터페이스을 구현하므로, 이 인터페이스가 유효한지 입증하는 참조 구현
    - 또한, 가비지 컬렉터의 영향을 배제해야 하는 성능 테스트, 스트레스 테스트 등에서도 활용 가능
- 단 몇 분, 몇 초 동안만 작동하는 애플리케이션
    - 전통적인 자바의 약점인 분야
        - 메모리를 많이 차지, 구동이 느림, JIT 로 인해 늦은 최적화
    - 이 경우 힙이 가득차기 전에 일을 마칠 것이므로 엡실론이 안성맞춤

## 3.7.2 컬렉터들 간 비교 및 취사 선택

### 선택 기준 3가지

1. 애플리케이션 주목적
    - 처리량(Throughput) 중시: 배치·과학 계산 등 → 최대 처리 성능
    - 지연 시간(Latency) 중시: SLA 서비스 등 → 짧은 일시 정지
    - 메모리 사용량 중시: 클라이언트·임베디드 애플리케이션 → 힙 풋프린트
2. 구동 서브시스템 환경
    - 하드웨어 아키텍처(x86, ARM 등)
    - CPU 코어 수, 가용 메모리 용량
    - 운영체제(리눅스, 윈도우, macOS 등)
3. JDK 제공자·버전
    - Azul Zing, Oracle JDK, OpenJDK, OpenJ9 등
    - 지원하는 JVM 스펙(가비지 컬렉터 종류)

### 지연 시간 최우선 예제

- 예산 여유·최적화 경험 부족 → Azul Zing VM + C4 컬렉터 사용 권장
- 상용 제품 불가·SW·HW 제어 가능 → 최신 Oracle/OpenJDK 버전 사용, 지연 시간 중요 시 ZGC 시도
- 레거시 시스템(구형 HW/SW)
    - 힙 메모리 4~6 GB 이하 → CMS
    - **힙 메모리 6 GB 이상 → G1**

### Oracle/OpenJDK 기본 권장 가이드라인

- 작은 메모리(<100 MB) 및 단일 프로세서·일시 정지 제약 없음 → Serial 컬렉터
- 최대 처리량 중시, 일시 정지 1 초 이상 허용 → Default(Parallel) 컬렉터
- **일시 정지 짧게, 응답 시간 중시 → G1**
- 극도의 지연 시간 민감 → ZGC

> 이론에만 의존하지 말고 실제 환경에서 벤치마크, 테스트를 통해 최적 컬렉터 선정 권장

## 3.7.3 가상 머신과 가비지 컬렉터 로그

### 개요

- JDK 8 이전: 가비지 컬렉터 로그 설정을 위한 매개변수들이 컬렉터별로 분산(-XX:+PrintGC, -XX:+PrintGCDetails 등)
- JDK 9 이후: 모든 핫스팟 기능 로그를 하나의 통합 프레임워크로 관리 (-Xlog 하나로 모든 로그 제어 가능)
    
    ```sql
    -Xlog[:[selector][:output][:decorators][:output-options]]
    ```
    
    - **selector**: 태그(gc, heap, safepoint, ergo, age 등)와 레벨(trace, debug, info, warning, error, off)
    - **decorators** (기본: uptime, level, tags)
        - time, uptime, timemillis, uptimemillis, timenanos, uptimenanos, pid, tid, level, tags

### 예시 1: 기존 GC 정보

```sql
java -Xlog:gc GCTest
```

```sql
// 가비지 컬렉터로 G1 사용
[0.222s] [info] [gc] Using G1
// 첫 번째 Young GC(0) 시작, Evacuation 후 힙 사용량 26M->5M(총 256M)
// 일시정지 시간: 355.623ms
[2.825s] [info] [gc] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M)
355.623ms
// 두 번째 Young GC(1) 시작, Evacuation 후 힙 사용량 14M->7M(총 256M)
// 일시정지 시간: 50.030ms
[3.096s] [info] [gc] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M)
50.030ms
// 세 번째 Young GC(2) 시작, Evacuation 후 힙 사용량 17M->10M(총 256M)
// 일시정지 시간: 40.576ms
[3.385s] [info] [gc] GC(2) Pause Young (G1 Evacuation Pause) 17M-10M(256M)
40.576ms
```

### 예시 2: 상세 GC 정보

- 와일드카드(*) 문자는 gc 태그의 모든 하위 프로세스를 포함한다는 뜻

```sql
java -Xlog:gc* GCTest
```

```java
// 힙 region 크기를 1MB 단위로 설정
[0.233s] [info] [gc, heap] Heap region size: 1M
// 가비지 컬렉터로 G1 사용
[0.383s] [info] [gc] Using G1
// 힙 coops 정보: 시작 주소
[0.383s] [info] [gc, heap, coops] Heap address: 0xfffffffe50400000,
// 힙 크기 및 압축 포인터 정보
size: 4064 MB, Compressed Oops mode: Non-zero based:
// 압축 Oops 기반 주소 및 shift amount
0xfffffffe50000000, Oop shift amount: 3
// 첫 번째 Young GC(0) 시작 (G1 Evacuation Pause)
[3.064s] [info] [gc, start ] GC(0) Pause Young (G1 Evacuation Pause)
// Evacuation 작업에 23 스레드 사용
gc, task GC (0) Using 23 workers of 23 for evacuation
// Pre Evacuate 단계 소요 시간 0.2ms
[3.420s] [info] [gc, phases ] GC (0) Pre Evacuate Collection Set: 0.2ms
// Evacuate 단계 소요 시간 348.0ms
[3.421s] [info] [gc, phases ] GC (0) Evacuate Collection Set: 348.0ms
// Post Evacuate 단계 소요 시간 6.2ms
gc, phases GC (0) Post Evacuate Collection Set: 6.2ms
// 기타 단계 소요 시간 2.8ms
[3.421s] [info] [gc, phases ] GC (0) Other: 2.8ms
// Eden 영역 24->0, 최대 9개
gc,heap GC (0) Eden regions: 24->0(9)
// Survivor 영역 0->3, 최대 3개
[3.421s] [info] [gc, heap ] GC (0) Survivor regions: 0->3(3)
// Old 영역 0->2
[3.421s] [info] [gc, heap ] GC (0) Old regions: 0->2
// Humongous 영역 2->1
[3.421s] [info] [gc, heap ] GC (0) Humongous regions: 2->1
// Metaspace 사용량 변화 없음 (4719K)
[3.421s] [info] [gc, metaspace ] GC (0) Metaspace: 4719K->4719K (1056768K)
// GC(0) Real 일시정지 시간만 표시
357.743ms
// User CPU 0.70s, Sys CPU 5.13s, Real 0.36s
[3.422s] [info] [gc, cpu ] GC (0) User-0.70s Sys-5.13s Real-0.36s
// 두 번째 Young GC(1) 시작 (G1 Evacuation Pause)
[3.648s] [info] [gc, start] GC (1) Pause Young (G1 Evacuation Pause)
// Evacuation 작업에 23 스레드 사용
[3.648s] [info] [gc, task] GC (1) Using 23 workers of 23 for evacuation
// Pre Evacuate 단계 소요 시간 0.3ms
[3.699s] [info] [gc, phases ] GC (1) Pre Evacuate Collection Set: 0.3ms
// Evacuate 단계 소요 시간 45.6ms
gc, phases GC (1) Evacuate Collection Set: 45.6ms
// Post Evacuate 단계 소요 시간 3.4ms
gc, phases GC (1) Post Evacuate Collection Set: 3.4ms
// 기타 단계 소요 시간 1.7ms
gc, phases GC (1) Other: 1.7ms
// Eden 영역 9->0, 최대 10개
gc, heap GC (1) Eden regions: 9->0(10)
// Survivor 영역 3->2, 최대 2개
[3.699s] [info] [gc, heap ] GC (1) Survivor regions: 3->2(2)
// Old 영역 2->5
[3.699s] [info] [gc, heap ] GC (1) Old regions: 2->5
// Humongous 영역 변동 없음 (1)
[3.700s] [info] [gc, heap] GC (1) Humongous regions: 1->1
// Metaspace 사용량 변화 없음 (4726K)
[3.700s] [info] [gc, metaspace ] GC (1) Metaspace: 4726K->4726K (1056768K)
// 컬렉션 전/후 힙 사용량 및 일시정지 시간 (14M->7M, 51.872ms)
[3.700s] [info] [gc] GC (1) Pause Young (G1 Evacuation Pause) 14M->7M(256M)
51.872ms
// User CPU 0.56s, Sys CPU 0.46s, Real 0.05s
[3.700s] [info] [gc, cpu ] GC (1) User-0.56s Sys-0.46s Real=0.05s
```

### 예시 3: 가비지 컬렉션 전후로 가용한 힙과 메서드 영역의 용량 변화를 확인

```sql
java -Xlog:gc+heap=debug GCTest
```

```sql
// 힙 region 크기를 1MB로 설정
[0.113s] [info] [gc, heap] Heap region size: 1M
// 힙 최소 및 초기 크기 설정 (8MB, 256MB)
[0.113s] [debug] [gc, heap] Minimum heap 8388608 Initial heap 268435456
// 힙 최대 크기 설정 (≈4GB)
Maximum heap 4261412864
// GC(0) 이전 상태: invocation=0, full GC=0
[2.529s] [debug] [gc, heap] GC (0) Heap before GC invocations=0 (full 0):
// GC(0) garbage-first heap 총 256MB 중 26MB 사용 중
[2.529s] [debug] [gc, heap] GC (0) garbage-first heap total 262144K, used 26624K
// GC(0) Humongous 영역 주소 범위
[2.529s] [debug] [gc, heap] [0xfffffffe50400000, 0xfffffffe50500800, 0xffffffff4e400000)
// GC(0) region 크기 1MB, Young 24개(24MB), Survivor 0개
[2.529s] [debug] [gc, heap] GC (0) region size 1024K, 24 young (24576K), 0 survivors (OK)
// Metaspace 사용량: 4.6MB/4.8MB(combined committed 5MB, reserved ~1GB)
[2.530s] [debug] [gc, heap] GC (0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
// Class space 사용량: 413K/464K(committed 512K, reserved ~1GB)
[2.530s] [debug] [gc, heap] GC (0) class space used 413K, capacity 464K, committed 512K, reserved 1048576K
// GC(0) 이후 Eden regions 24->0(9)
[2.892s] [info] [gc, heap] GC (0) Eden regions: 24->0(9)
// GC(0) 이후 Survivor regions 0->3(3)
[2.892s] [info] [gc, heap] GC (0) Survivor regions: 0->3(3)
// GC(0) 이후 Old regions 0->2
[2.892s] [info] [gc, heap] GC (0) Old regions: 0->2
// GC(0) 이후 Humongous regions 2->1
[2.892s] [info] [gc, heap] GC (0) Humongous regions: 2->1
// GC(0) 완료 후 상태: invocation=1, full GC=0
[2.893s] [debug] [gc, heap] GC (0) Heap after GC invocations=1 (full 0):
// GC(0) garbage-first heap 총 256MB 중 5.7MB 사용 중
[2.893s] [debug] [gc, heap] GC (0) garbage-first heap total 262144K, used 5850K
// GC(0) Humongous 영역 주소 범위 유지
[2.893s] [debug] [gc, heap] [0xfffffffe50400000, 0xfffffffe50500800, 0xffffffff4e400000)
// GC(0) region 크기 1MB, Young 3개(3MB), Survivor 3개(3MB)
[2.893s] [debug] [gc, heap] GC (0) region size 1024K, 3 young (3072K), 3 survivors (3072K)
// Metaspace 사용량 변화 없음
[2.893s] [debug] [gc, heap] GC (0) Metaspace used 4719K, capacity 4844K, committed 5120K, reserved 1056768K
// Class space 사용량 변화 없음
[2.893s] [debug] [gc, heap] GC (0) class space used 413K, capacity 464K, committed 512K, reserved 1048576K
```

### 예시 4: GC 중 사용자 스레드의 동시 실행 시간과 일시 정지 시간을 확인

```sql
java -Xlog:safepoint GCTest
```

```sql
[1.376s] [info] [safepoint] Application time: 0.3091519 seconds
[1.377s] [info] [safepoint] Total time for which application threads were
stopped: 0.0004600 seconds, Stopping threads took:
0.0002648 seconds
[2.386s] [info] [safepoint] Application time: 1.0091637 seconds
[2.387s] [info] [safepoint] Total time for which application threads were
stopped: 0.0005217 seconds, Stopping threads took:
0.0002297 seconds
```

### 예시 5: 컬렉터에서 제공하는 인간 공학 메커니즘의 자동 조절 관련 정보 확인

```sql
java -Xlog:gc+ergo*=trace GCTest
```

```sql
// 초기 Refine Zones 정보: green, yellow, red 영역 개수 및 최소 yellow size
[0.122s] [debug] [gc, ergo, refine] Initial Refinement Zones: green: 23, yellow: 69, red: 115, min yellow size: 46
// 힙 확장 요청: 요청된 크기 및 실제 확장된 크기
[0.142s] [debug] [gc, ergo, heap ] Expand the heap. requested expansion amount: 268435456B expansion amount: 2684354568
// GC(0) CSet 선택 시작: 대기 카드 수, 예측 기본 시간, 남은 시간, 목표 일시정지 시간
[2.475s] [trace] [gc,ergo,cset] GC (0) Start choosing CSet. pending cards: predicted base time: 10.00ms remaining time: 190.00ms target pause time: 200.00ms
// GC(0) Young 영역을 CSet에 추가: eden, survivor 개수 및 예측 시간
[2.476s] [trace] [gc,ergo,cset ] GC (0) Add young regions to CSet. eden: 24 regions, survivors: 0 regions, predicted young region time: 367.19ms, target pause time: 200.00ms
// GC(0) CSet 선택 완료: old 영역 개수, 예측 old 처리 시간, 남은 시간
[2.476s] [debug] [gc,ergo, cset ] GC (0) Finish choosing CSet. old: 0 regions, predicted old region time: 0.00ms, time remaining: 0.00
// GC(0) Clear Card Table Task 실행: 워커 수 및 처리 대상 영역 수
[2.826s] [debug] [gc, ergo ] GC (0) Running G1 Clear Card Table Task using 1 workers for 1 units of work for 24 regions.
// GC(0) Free Collection Set Task 실행: 워커 수 및 collection set 크기
[2.827s] [debug] [gc,ergo ] GC (0) Running G1 Free Collection Set using 1 workers for collection set length 24
// Refinement Zones 업데이트: 소요 시간, 버퍼 개수, 목표 시간
[2.828s] [trace] [gc, ergo, refine] GC (0) Updating Refinement Zones: update_rs time: 0.004ms, update_rs buffers: 0, update_rs goal time: 19.999ms
```

### 예시 6: 회수 후 남은 객체들의 나이 분포 확인

```sql
java -Xlog:gc+age=trace GCTest
```

```sql
// Desired survivor size: 1.5MB, new age threshold: 15 (최대 15)
[2.406s] [debug] [gc,age] GC (0) Desired survivor size 1572864 bytes, new threshold 15 (max threshold 15)
// Age table 설정 시점, threshold: 15 (max 15)
[2.745s] [trace] [gc,age] GC (0) Age table with threshold 15 (max threshold 15)
// age=1 세대 live 객체: 3.1MB (총 3.1MB)
[2.745s] [trace] [gc,age] GC (0) age 1: 3100640 bytes, 3100640 total
// Desired survivor size for GC(5): 2MB, age threshold 유지 15
[4.700s] [debug] [gc,age] GC (5) Desired survivor size 2097152 bytes, new threshold 15 (max threshold 15)
// GC(5) Age table 설정, threshold: 15 (max 15)
[4.810s] [trace] [gc,age] GC (5) Age table with threshold 15 (max threshold 15)
// GC(5) age=1 세대 live 객체: ~2.66MB (총 2.66MB)
[4.810s] [trace] [gc, age] GC (5) age 1: 2658280 bytes, 2658280 total
// GC(5) age=2 세대 live 객체: ~1.53MB, 누적 총 4.19MB
[4.810s] [trace] [gc,age] GC (5) age 2: 1527360 bytes, 4185640 total
```

## 3.7.4 가비지 컬렉터 매개 변수 정리

### 로그 관련 매개 변수 변화

| JDK 8까지의 로그 매개 변수 | JDK 9 이후의 형태 |
| --- | --- |
| G1PrintHeapRegions | Xlog:gc+region=trace |
| G1PrintRegionLivenessInfo | Xlog:gc+liveness=trace |
| G1SummarizeConcMark | Xlog:gc+marking=trace |
| G1SummarizeRSetStats | Xlog:gc+remset*=trace |
| GCLogFileSize, NumberOfGCLogFiles, UseGCLog File Rotation | Xlog:gc*:file=<file>::filecount=<count>, filesize=<filesize in kb> |
| PrintAdaptiveSizePolicy | Xlog:gc+ergo*=trace |
| PrintClassHistogramAfterFullGC | Xlog:classhisto*=trace |
| PrintClassHistogramBeforeFullGC | Xlog:classhisto*=trace |
| PrintGCApplicationConcurrentTime | Xlog:safepoint |
| PrintGCApplicationStoppedTime | Xlog:safepoint |
| PrintGCDateStamps | time 데커레이터 사용 |
| PrintGCTaskTimeStamps | Xlog:gc+task=trace |
| PrintGCTimeStamps | uptime 데커레이터 사용 |
| PrintHeapAtGC | Xlog:gc+heap=debug |
| PrintHeapAtGCExtended | Xlog:gc+heap=trace |
| PrintJNIStalls | Xlog:gc+jni=debug |
| PrintOldPLAB | Xlog:gc+plab=trace |
| PrintParallelOldGCPhaseTimes | Xlog:gc+phases=trace |
| PrintPLAB | Xlog:gc+plab=trace |
| PrintPromotionFailure | Xlog:gc+promotion=debug |
| PrintReferenceGC | Xlog:gc+ref=debug |
| PrintStringDeduplicationStatistics | Xlog:gc+stringdedup |
| PrintTaskqueue | Xlog:gc+task+stats=trace |
| PrintTenuringDistribution | Xlog:gc+age=trace |
| PrintTerminationStats | Xlog:gc+task+stats=debug |
| PrintTLAB | Xlog:gc+tlab=trace |
| TraceAdaptiveGCBoundary | Xlog:heap+ergo=debug |
| TraceDynamicGCThreads | Xlog:gc+task=trace |
| TraceMetaspaceHumongousAllocation | Xlog:gc+metaspace+alloc=debug |
| G1TraceConcRefinement | Xlog:gc+refine=debug |
| G1TraceEagerReclaimHumongousObjects | Xlog:gc+humongous=debug |
| G1TraceStringSymbolTableScrubbing | Xlog:gc+stringtable=trace |

### 가비지 컬렉터와 관련해 많이 쓰이는 매개 변수들

| 매개 변수 | 설명 |
| --- | --- |
| UseSerialGC | 클라이언트 모드 기본값. 시리얼 + 시리얼 올드 컬렉터 조합 사용 |
| UseParNewGC | 파뉴 + 시리얼 올드 컬렉터 조합 사용. JDK 9부터 지원하지 않음 |
| UseConcMarkSweepGC | 파뉴 + CMS + 시리얼 올드 컬렉터 조합 사용. 동시 모드 실패 시 백업 역할. JDK 14부터 지원하지 않음 |
| UseParallelGC | JDK 8까지 서버 모드 기본값. 패러렐 컬렉터 조합 사용 |
| UseParallelOldGC | PS + 패러럴 올드 컬렉터 조합 사용. JDK 15부터 지원하지 않음 |
| SurvivorRatio | 신세대 Eden:Survivor 비율. 기본값 8 (8:1) |
| TargetSurvivorRatio | 생존자 공간 최대 사용 비율. 초과 시 모든 객체를 나이와 관계없이 구세대로 승격 |
| PretenureSizeThreshold | 바로 구세대에 생성할 객체 크기 최소값. 초과 시 처음부터 구세대에 생성 |
| MaxTenuringThreshold | 구세대로 승격될 나이 임계치. Minor GC마다 나이 +1, 설정값 초과 시 승격. 범위 0~16 |
| UseAdaptiveSizePolicy | 힙 영역 크기, 승격 나이, 생존자 공간 비율 등을 VM이 동적으로 조율 |
| HandlePromotionFailure | 할당 보증 실패 허용 여부. 극한 상황에서 에덴+생존자 → 구세대 공간 부족 시 동작 |
| ParallelGCThreads | 패러렐 GC에 사용할 스레드 수 |
| GCTimeRatio | 전체 시간 중 GC 시간 비율. 기본값 99 (1%). PS 컬렉터에 적용 |
| MaxGCPauseMillis | GC 최대 일시 정지 시간. PS 컬렉터에 적용 |
| CMSInitiatingOccupancyFraction | CMS 시작 힙 점유율 임계값. 기본값 68%. CMS 컬렉터에 적용 |
| UseCMSCompactAtFullCollection | GC 완료 후 메모리 조각 모음 수행. CMS 컬렉터에 적용. JDK 9부터 폐기 대상 |
| CMSFullGCsBeforeCompaction | 지정 횟수 GC 후 메모리 조각 모음 수행. CMS 컬렉터에 적용. JDK 9부터 폐기 대상 |
| UseG1GC | G1 컬렉터 사용. JDK 9 이후 서버 모드 기본값 |
| G1HeapRegionSize | G1 리전 크기(최종값 아님) |
| MaxGCPauseMillis | G1 회수 프로세스 목표 시간. 기본값 200ms (권장사항 아님) |
| G1NewSizePercent | 신세대 최소 크기 비율. 기본값 5% |
| G1MaxNewSizePercent | 신세대 최대 크기 비율. 기본값 60% |
| ConcGCThreads | 동시 처리(표시 등) 단계별로 사용할 스레드 수 |
| InitiatingHeapOccupancyPercent | 표시 주기 시작 힙 점유율 임계값. 기본값 45% (old_humongous 포함) |
| UseShenandoahGC | Shenandoah 컬렉터 사용. OpenJDK 12+ 또는 백포트 릴리스에서만. -XX:+UnlockExperimentalVMOptions 필요 |
| ShenandoahGCHeuristics | Shenandoah GC 시작 전략(adaptive, static, compact, passive, aggressive) |
| UseZGC | ZGC 사용. JDK 14 이전에는 -XX:+UnlockExperimentalVMOptions 필요 |
| ZGenerational | 세대 구분 ZGC 사용. UseZGC와 함께. JDK 21부터 공식 지원 예정 |
| UseNUMA | NUMA 메모리 할당 지원. Parallel 및 ZGC 지원, G1은 JDK 14부터 지원 |

# 3.8 실전: 메모리 할당과 회수 전략

## 개요

- 자바 기술 시스템이 제공하는 자동 메모리 관리의 가장 근본적 목표
    - 객체의 메모리를 자동으로 할당, 자동으로 회수하는 것
- ‘객체 메모리 할당’ → 개념적으로는 ‘힙에 할당’ 한다는 뜻
    - 이번 절에서는 ‘시리얼 컬렉터’ 를 사용해 가장 기본적인 메모리 할당 정책을 설명하고, 코드를 통해 검증
    - `xlog:gc*` 매개 변수는 가비지 컬렉션 시 메모리 회수 로그를 출력하고, 프로세스 종료 시 메모리 각 영역의 할당 내용을 출력

## 3.8.1 객체는 먼저 에덴에 할당된다

### 개요

- 대부분의 경우 객체는 신세대의 에덴에 할당
    - 에덴 공간이 부족해지면 마이너 GC 가 시작됨

### 코드

- -Xmn10M (신세대 영역 크기를 10m로)
- -XX:SurvivorRatio=8 (에덴:생존자 비율을 8:1로 설정)
    - 신세대에서 사용할 수 있는 총 공간은 `9,216KB` (에덴의 용량+생존자 공간 1개의 용량)
    
    <img width="643" height="255" alt="Image" src="https://github.com/user-attachments/assets/2a88cd36-ea24-444c-8c28-62eaf9f46991" />
    

```java
/**
* VM 매개 변수: -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
* -Xlog:gc*
*/
public static void testAllocation() {
		byte[] alloc1, alloc2, alloc3, alloc4;
		alloc1= new byte[2* _1MB];
		alloc2 = new byte[2 * _1MB];
		alloc3= new byte[2* _1MB];
		alloc4 = new byte[4*_1MB]; // 마이너 GC 발생
}
```

### 결과

> tenured: 종신직의 (구세대)

```java
Using Serial← 시리얼 가비지 컬렉터 사용
Version: 17+35-2724 (release)
...

GC(0) Pause Young (Allocation Failure) ← 할당 실패로 GC 촉발
GC(8) DefNew: 7292K(9216K)->672K(9216K) ← GC 결과(신세대)
		Eden: 7292K(8192K)->OK(8192K)
		From: OK(1024K)->672K(1024K)
GC(0) Tenured: OK(10240K)->6144K(10240K) ← GC 결과(구세대)
...

Heap
def new generation total 9216K, used 4850K← 신세대
	**eden space 8192K, 51% used ← 에덴 (alloc 4)
	from space 1024K, 65% used ← 생존자 공간(from, 기타)
	to space 1024K, 0% used ← 생존자 공간(to)
tenured generation total 10240K, used 6144K← 구세대 (alloc 1 ~ 3)**
```

- `alloc4` 객체를 생성하려 할 때 에덴에 6MB 이상이 차있기 때문에 마이너 GC 가 발생

    <img width="608" height="267" alt="Image" src="https://github.com/user-attachments/assets/4e64c23e-21cc-4323-82d6-e1a79192d260" />
    
- 이때, 생존자 공간의 크기는 겨우 1MB 이므로 `할당 보증 메커니즘`이 발동하여 바로 구세대로 옮겨짐
    - 아직 `alloc1` ~ `alloc3` 에 대한 참조가 살아있으므로 회수할 순 없음
    
    <img width="639" height="491" alt="Image" src="https://github.com/user-attachments/assets/97c944ae-b138-46f6-848a-144efb415354" />
    

## 3.8.2 큰 객체는 곧바로 구세대에 할당된다

### 개요

- 큰 객체
    - 커다란 ‘연속된’ 메모리 공간을 필요로 하는 자바 객체
    - 매우 긴 문자열, 원소가 매우 많은 배열 등
- JVM에게 좋지 않은 소식
    1. 큰 객체의 등장 → 연속된 공간 확보를 위해 수많은 다른 객체를 옮겨야 함
    2. 곧 사라질 객체의 떼거지 등장 → 여유 공간이 많이 있음에도 가비지 컬렉션을 해야만 하는 상황을 자주 많듦

### 코드

- `-XX:PretenureSizeThreshold=3M`
    - 설정 값보다 큰 객체는 곧바로 구세대에 할당
    - 에덴과 두 생존자 공간 사이의 대규모 복사를 줄이는 목적
    - `시리얼`과 `파뉴 신세대 컬렉터` 에만 적용 가능

```java
/**
* VM 매개 변수: -XX:+UseSerialGC-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
							-Xlog:gc* -XX:PretenureSizeThreshold=3M
*/
public static void test PretenureSizeThreshold() {
		byte[] alloc;
		alloc = new byte[4 * _1MB]; // 곧장 구세대에 할당
}
```

### 결과

```java
Heap
	def new generation total 9216K, used 1312k
			eden space 8192K, 16% used
			from space 1024K, 0% used
			to   space 1024K, 0% used
	**tenured generation    total 10240K, used 4096K ← alloc (구세대)**
```

## 3.8.3 나이가 차면 구세대로 옮겨진다

### 개요

- 메모리를 청소할 때, 어떤 생존 객체를 신세대에 남겨두고 어떤 생존 객체를 구세대로 옮길지 정해야 함
    - 가상 머신은 각 객체의 객체 헤더에 세대 나이 카운터를 둠
    - 태어났을 때의 나이는 0
    - 에덴 → 생존자 → 다른 생존자 로 이동 시 마다 1씩 증가
    - 특정 나이가 되면 구세대로 승격 (`-XX:MaxTenuring Threshold` 에 의존)

### 코드

```java
/**
* VM 매개 변수: -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX: SurvivorRatio=8
              -Xlog:gc* -Xlog:gc+age=trace **-XX:MaxTenuringThreshold=1**
* 또는
* VM 매개 변수: -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
              -Xlog:gc* -Xlog:gc+age=trace **-XX:MaxTenuringThreshold=15**
              -XX:TargetSurvivorRatio=80
*/
SuppressWarnings("unused")
public static void test Tenuring Threshold() {
		byte[] allocl, alloc2, alloc3;
		
		// 구세대 이동 시기는 -XX:MaxTenuring Threshold가 결정
		alloc1 = new byte[_1MB / 8];
		alloc2 = new byte[4 * _1MB];
		alloc3 = new byte[4 * _1MB]; // 첫 번째 GC 발생
		alloc3 = null;
		alloc3 = new byte[4 * _1MB]; // 두 번째 GC 발생
}
```

### 결과

- 첫번째
    - alloc1 은 크기가 64kb 이므로 생존자 공간에 수용
    - `-XX:MaxTenuringThreshold=1` 로 인해 두번째 GC 때 구세대로 이동
    - 최종적으로 신세대 메모리 사용량은 GC 후 0kb

```java
GC(0) Pause Young (Allocation Failure) ← 첫 번째 GC
GC(0) Age table with threshold 1 (max threshold 1) ← 최대 나이
GC (0) DefNew: 5372K (9216K)->800K(9216K)
		Eden: 5372K(8192K)->0K(8192K)
		From: 0K(1024K)->800K(1024K) ← alloc1
GC (0) Tenured: 0K(10240K)->4096K (10240K) ← alloc2
...

GC (1) Pause Young (Allocation Failure) + GC
GC (1) DefNew: 4896K (9216K)->0K(9216K)
		Eden: 4096K(8192K)->0K(8192K)
		From: 800K(1024K)->0K(1024K) ← 나이가 차 구세대로 이동
GC (1) Tenured: 4096K (10240K)->4896K (10240K) ← alloc2 + alloc1
...

Heap
	def new generation total 9216K, used 4178K ...
		eden space 8192K, 51% used ... ← alloc3
		from space 1024K, 0% used...
		to space 1024K,   0% used...
	tenured generation total 10240K, used 5024K... ← alloc1, alloc2
```

- 두번째
    - alloc1 객체는 두번쨰 GC 이후에도 여전히 생존자 공간에 남음
    - `-XX:TargetSurvivorRatio` : 생존자 공간이 지정한 비율 이상 차면 살아남은 객체들을 구세대로 이동
        - 이때 나이는 고려 X
        - 현재는 800/819kb 이므로 78% 수준이라 이동 X

```java
GC (0) Pause Young (Allocation Failure) ← 첫 번째 GC
GC (0) Desired survivor size 838856 bytes,
		new threshold 15 (max threshold 15)
GC (0) DefNew: 5372K (9216K)->800K(9216K)
		Eden: 5372K(8192K)->0K(8192K)
		From: 0K(1024K)->800K(1024K) ← alloc1
GC (0) Tenured: OK(10240K)->4096K(10240K) ← alloc2
...

GC (1) Pause Young (Allocation Failure) ← 두번째 GC
GC (1) DefNew: 4896K (9216K)->800K(9216K)
		Eden: 4096K(8192K)->0K(8192K)
		From: 800K(1024K)->800K(1024K) ← alloc1
GC (1) Tenured: 4096K (10240K)->4096K (10240K) ← alloc2
...

Heap
	def new generation total 9216K, used 4978K ...
		eden space 8192K, 51% used... ← alloc3
		from space 1024K, 78% used... ← alloc1
		to space 1024K, 0% used ...
	tenured generation total 10240K, used 4096K ... ← alloca
```

## 3.8.4 공간이 비좁으면 강제로 승격시킨다

### 개요

- `-XX:TargetSurvivorRatio` 이야기
    - 기본 값은 50% → 생존 객체 전체의 크기 총합이 생존자 공간 절반을 넘어서면 모든 객체를 구세대로 옮김

### 코드

```java
/**
* VM 매개 변수: -XX:+UseSerialGC-Xms20M-Xmx20M -Xmn10M-XX:SurvivorRatio=8
							-Xlog:gc* -Xlog: gc+age=trace -XX:MaxTenuring Threshold=15
							-XX:TargetSurvivorRatio=80
*/
public static void testTenuring Threshold2(){
		byte[] allocl, alloc_new, alloc2, alloc3;
		alloc1 = new byte[_1MB / 8];
		alloc_new = new byte[_1MB/16];
		// alloc1 + alloc_new= 생존자 공간의 80% 초과
		alloc2 = new byte[4 * _1MB];
		alloc3 new byte[4 * _1MB]; // 첫번째 GC 발생
		alloc3 = null;
		alloc3 = new byte[4 * _1MB]; // 두번째 GC 발생
}
```

### 결과

- 두번째 GC 때 생존자 공간 목표 비율인 80% 를 넘어서, 구세대로 이동

```java
GC(0) Pause Young (Allocation Failure) ← 첫 번째 GC
GC(0) Desired survivor size 838856 bytes,
    new threshold 1 (max threshold 15)
GC(0) Age table with threshold 1 (max threshold 15)
GC(0) - age   1:        885400 bytes,        885400 total
GC(0) DefNew: 5436K(9216K)->864K(9216K)
     Eden: 5436K(8192K)->0K(8192K)
     From: 0K(1024K)->864K(1024K)    ← alloc1, alloc_new
GC(0) Tenured: 0K(10240K)->4096K(10240K) ← alloc2
...
GC(1) Pause Young (Allocation Failure) ← 두 번째 GC
GC(1) Desired survivor size 838856 bytes,
    new threshold 15 (max threshold 15)
GC(1) Age table with threshold 15 (max threshold 15)
GC(1) DefNew: 4960K(9216K)->0K(9216K)
     Eden: 4096K(8192K)->0K(8192K)
     From: 864K(1024K)->0K(1024K)    ← 80% 초과, 구세대로 이동
GC(1) Tenured: 4096K(10240K)->4960K(10240K) ← alloc2 + alloc1, alloc_new
...
Heap
    def new generation   total 9216K, used 4178K
    eden space 8192K,   51% used ← alloc3
    from space 1024K,   0% used
    to   space 1024K,   0% used
    tenured generation   total 10240K, used 4960K ← alloc1, alloc_new, alloc2
...
```

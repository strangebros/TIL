# 11장 결제 시스템

# 1단계: 문제 이해 및 설계 범위 확정

1. **결제 시스템의 정의 및 중요성**
    - 결제 시스템은 금전적 가치 이전을 통해 금융 거래를 정산하는 데 사용되는 모든 제도, 절차, 기술을 포함함
    - 전자상거래의 폭발적인 성장에 필수적이며, 작은 실수도 큰 매출 손실로 이어질 수 있는 부담스러운 시스템임
2. **설계 범위 확정 (전자상거래 환경 가정)**
    - **대상 애플리케이션:** 아마존닷컴과 같은 전자상거래 애플리케이션의 결제 백엔드를 구축하는 것을 가정함
    - **지원 결제 방법:** 실생활에서 사용 가능한 모든 옵션을 지원해야 하지만, 이번 면접에서는 **신용 카드 결제**만 처리하는 것으로 한정함
    - **결제 처리 주체:** 신용 카드 데이터의 보안 및 법규 준수(PCI DSS 등) 문제로 인해, 민감한 데이터 처리는 스트라이프(Stripe) 같은 **전문 결제 처리 업체(PSP)**에 의존함
    - **국제 지원:** 전 세계적으로 사용될 수 있는 애플리케이션이지만, 면접에서는 **하나의 통화**만 사용한다고 가정함
    - **규모:** 하루 **100만 건의 거래**가 이루어진다고 가정함 (초당 약 10TPS)
    - **추가 요구사항:** 판매자에게 매월 지급 대금을 정산하는 절차(Pay-out)를 지원해야 함
3. **기능 및 비기능 요구사항**
    - **기능 요구사항:** 대금 수신, 대금 정산
    - **비기능 요구사항:** 신뢰성 및 내결함성, 내부 서비스 간 조정 프로세스

# 2단계: 개략적 설계안 제시 및 동의 구하기

## 2.1. 결제 자금의 흐름 (Pay-in 및 Pay-out)

1. **대금 수신 (Pay-in) 흐름**
    - 구매자가 주문하면 돈이 아마존의 은행 계좌로 들어옴
    - 이 돈의 소유권은 대부분 판매자에게 있으며, 아마존은 수수료를 받고 자금 관리자 역할만 수행함
2. **대금 정산 (Pay-out) 흐름**
    - 제품이 배송되는 등 조건이 충족되면, 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급됨

## 2.2. 대금 수신 흐름의 구성 요소

1. **결제 서비스 (Payment Service)**
    - 사용자로부터 결제 이벤트를 수락하고 AML/CFT(자금 세탁 방지/테러 자금 조달 방지)와 같은 규정을 준수하는지 위험 점검(risk check)을 수행함
    - 위험 확인을 통과한 결제만 처리하며, 일반적으로 복잡성 때문에 제3자 제공업체(PSP)를 이용함
2. **결제 실행자 (Payment Executor)**
    - 하나의 결제 이벤트에 포함될 수 있는 여러 **결제 주문(payment order)** 중 하나를 PSP를 통해 실행하는 역할을 담당함
3. **결제 서비스 공급자 (PSP, Payment Service Provider)**
    - 구매자의 신용 카드 계정에서 돈을 인출하여 전자상거래 웹사이트의 계좌로 옮기는 역할을 담당함 (예: Toss Payments, NHN KCP, NICE 정보통신, …)
4. **카드 유형 (Card Scheme)**
    - 신용 카드 업무를 처리하는 조직으로, 비자(VISA), 마스터카드(MasterCard) 등이 있음
5. **원장 (Ledger)**
    - 결제 트랜잭션에 대한 금융 기록을 저장함
    - 총 수익 계산, 수익 분석 등 **결제 후 분석(post-payment analysis)**에 매우 중요한 역할을 함
6. **지갑 (Wallet)**
    - 특정 사용자나 판매자(merchant)의 계정 잔액을 기록함

## 2.3. 일반적인 결제 흐름 (9단계)

1. 사용자가 '주문하기' 클릭 시 결제 이벤트가 생성되어 결제 서비스로 전송되고 데이터베이스에 저장됨
2. 결제 서비스는 결제 이벤트를 데이터베이스에 저장함
3. 단일 결제 이벤트에 여러 판매자의 제품이 포함된 경우, 결제 서비스는 이를 여러 결제 주문으로 분할하고 결제 실행자를 호출함
4. 결제 실행자는 결제 주문을 데이터베이스에 저장함
5. 결제 실행자는 PSP를 외부 호출하여 신용 카드 결제를 처리함
6. 결제 실행자가 결제를 성공적으로 처리하면 지갑 서비스를 호출하여 특정 판매자의 잔고를 갱신함
7. 지갑 서버는 갱신된 잔고 정보를 데이터베이스에 저장함
8. 지갑 서비스가 잔고 갱신에 성공하면 결제 서비스는 원장 서비스를 호출하여 원장 데이터베이스에 새 정보를 추가함
9. 원장 서비스는 원장 데이터베이스에 새 정보를 추가함

## 2.4. 결제 서비스 API 및 데이터 모델

1. **결제 서비스 API (RESTful)**
    - `POST /v1/payments`: 결제 이벤트를 실행하는 엔드포인트임 하나의 이벤트에 여러 결제 주문이 포함될 수 있음
        - `payment_order_id`는 전역적으로 고유한 ID이며, PSP에 요청을 전송할 때 **멱등 키(idempotency key)**로 사용되어 중복 요청을 제거함
        - 금액(amount)의 자료형은 정밀도 문제와 반올림 오류를 방지하기 위해 'double' 대신 **'string'**을 사용함
    - `GET /v1/payments/{:id}`: `payment_order_id`가 가리키는 단일 결제 주문의 실행 상태를 반환함
2. **저장소 솔루션 선택 기준**
    - 결제 시스템용 저장소는 성능보다는 **안정성**에 중점을 둠
    - **선호되는 데이터베이스:** 트랜잭션을 지원하는 전통적인 **ACID 관계형 데이터베이스**를 선호함
    - **주요 고려사항:** 안정성, 모니터링 & 감사 용이성, DBA 채용 시장 성숙도
3. **결제 테이블 스키마 (Payment Event)**
    - checkout_id, buyer_info, seller_info, amount, payment_order_id, is_payment_done 등의 필드 포함
4. **결제 주문 테이블 스키마 (Payment Order)**
    - payment_order_id, buyer_account, seller_account, amount, currency, payment_order_status, wallet_updated, ledger_updated 등의 필드 포함

## 2.5. 결제 주문 상태 업데이트 로직

1. **초깃값:** payment_order_status의 초깃값은 **NOT_STARTED**임
2. **실행 중:** 결제 서비스가 결제 실행자에 주문을 전송하면 상태는 **EXECUTING**으로 바뀜
3. **결과 반영:** 결제 처리자의 응답에 따라 상태는 **SUCCESS** 또는 **FAIL**로 변경됨
4. **지갑 및 원장 업데이트**
    - 상태가 SUCCESS로 결정되면 지갑 서비스를 호출하여 판매자 잔액을 업데이트하고 wallet_updated 필드를 TRUE로 설정함
    - 지갑 업데이트가 끝나면 원장 서비스를 호출하여 원장 데이터베이스를 갱신하고 ledger_updated 필드를 TRUE로 설정함
5. **결제 이벤트 완료:** 동일한 checkout_id 아래의 모든 결제 주문이 성공적으로 처리되면 결제 이벤트 테이블의 is_payment_done을 TRUE로 업데이트함
6. **모니터링 scheduled job:**
    1. 종결되지 않은 결제 주문을 주기적으로 모니터링
    2. 임계 기간을 지난 결제 주문이 있는 경우, 수동으로 확인할 수 있도록 엔지니어에게 경보 발송

## 2.6. 복식부기 원장 시스템

1. **복식부기 (Double-entry bookkeeping) 원칙**
    - 모든 결제 거래를 **두 개의 원장 계좌**에 같은 금액으로 기록하는 회계 원칙임
    - 한 계좌에서는 차감(Debit)이 이루어지고 다른 계좌에는 입금(Credit)이 이루어짐
    - 예: 구매자 계정에서 $1 차감, 판매자 계정에서 $1 증가

        | **계정** | **차감** | **증가** |
        | --- | --- | --- |
        | 구매자 | $1 |  |
        | 판매자 |  | $1 |

2. **일관성 보장:** 복식부기 시스템에서 모든 거래 항목의 합계는 **0**이어야 함
    - 이 시스템을 활용하면 자금 흐름을 추적하고 결제 주기 전반에 걸쳐 **일관성**을 보장할 수 있음

## 2.7. 외부 결제 페이지 활용

1. **PCI DSS 규정 준수:** 대부분의 기업은 PCI DSS(Payment Card Industry Data Security Standard)와 같은 복잡한 규정을 준수해야 하므로, 신용 카드 정보를 내부에 직접 저장하지 않음
2. **외부 페이지 사용:** 기업들은 PSP에서 제공하는 **외부 신용 카드 페이지(hosted credit card page)**를 사용함
3. **작동 방식:** 이 페이지는 웹사이트의 iframe 위젯이나 모바일 앱의 SDK에 포함되어 있으며, **PSP가 직접 고객의 카드 정보를 수집**함. '우리 결제 서비스'는 민감한 카드 정보를 직접 수집하지 않음

## 2.8. 대금 정산 흐름 (Pay-out)

1. 대금 정산 흐름은 대금 수신 흐름과 유사
    1. 대금 수신이 구매자 신용 카드에서 전자상거래 웹사이트 계좌로 이체하는 것이라면, 대금 정산은 **전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체**하는 것
2. 외상 정산 및 복잡한 부기 규제 요구사항 때문에 티팔티(Tipalti)와 같은 **지급 서비스 제공업체**를 이용하는 것이 일반적

# 3단계: 상세 설계

## 3.1. PSP 연동 상세 흐름 (외부 결제 페이지 이용)

1. **일반적인 연동 방법:** 대부분의 회사는 PSP와 직접 연결하지 않고 다음 두 가지 방법 중 하나를 택함
    - **API 연동:** 회사가 민감한 결제 정보를 안전하게 저장할 수 있는 경우, 자체 웹페이지를 개발하고 PSP는 은행 연결 및 카드 유형 지원 역할을 함
    - **외부 결제 페이지 제공 (일반적):** 복잡한 규정 및 보안 문제로 민감한 정보를 저장하지 않기로 결정한 경우, PSP가 결제 페이지를 제공함 (대부분의 기업이 택하는 접근법임)
2. **외부 결제 페이지 이용 흐름 (9단계)**
    1. 클라이언트가 '결제' 버튼 클릭 후 결제 주문 정보를 담아 결제 서비스를 호출함
    2. 결제 서비스는 **`비중복 난수(UUID)`**를 포함한 결제 등록 요청을 PSP로 전송함 이 난수는 결제 주문의 ID로 사용됨
    3. PSP는 등록된 결제 요청을 유일하게 식별하는 **`토큰(UUID)`**을 결제 서비스에 반환함
    4. 결제 서비스는 PSP가 제공하는 외부 결제 페이지를 호출하기 전에 이 토큰을 데이터베이스에 저장함
    5. 클라이언트는 PSP가 제공하는 외부 결제 페이지를 표시함 (PSP의 자바스크립트 라이브러리가 민감한 정보를 직접 수집함)
    6. 사용자가 결제 정보를 입력하고 결제 버튼을 클릭하면 PSP가 결제 처리를 시작함
    7. PSP가 결제 상태를 반환하면, 사용자는 사전에 등록된 **리디렉션 웹 URL**로 보내짐
    8. 리디렉션 URL에는 결제 상태가 추가되어 결제 시스템에 전달됨
    9. PSP는 결제 상태와 함께 **웹훅(webhook)**을 통해 결제 서비스를 비동기적으로 호출하여 최종 결제 완료 결과를 알림 결제 시스템은 이 웹훅을 통해 payment_order_status를 최신 상태로 업데이트함

## 3.2. 조정 (Reconciliation)

1. **조정의 필요성:** 시스템 구성 요소가 **비동기적으로 통신**하는 경우 메시지 전달이나 응답 반환이 보장되지 않아 **정확성을 보장하기 어려움**
2. **작동 방식**
    1. PSP나 은행은 매일 밤 **정산 파일**을 고객에게 보냄
    2. 이 파일에는 은행 계좌의 **하루 동안의 잔액과 모든 거래 내역**이 기재되어 있음
3. **조정 시스템의 역할:** 조정 시스템은 정산 파일의 세부 정보를 읽어 **내부 원장 시스템**과 비교하여 정보가 일치하는지 확인함
4. **불일치 문제 해결 방안**
    - **자동화 가능 문제:** 원인과 해결 방법을 알고 있어 자동화 프로그램을 작성하여 해결함
    - **자동화 불가능 문제:** 원인과 해결 방법을 알지만 자동화 비용이 높은 경우, 불일치 문제를 **작업 대기열**에 넣고 **재무팀이 수동으로 수정**하도록 함
    - **유형을 알 수 없는 문제:** 불일치가 어떻게 발생했는지 분류할 수 없는 경우, 특별 작업 대기열에 넣고 재무팀에서 조사하도록 함

## 3.3. 결제 지연 처리

1. **지연 발생 사례**
    1. 결제 요청은 몇 초 만에 처리되기도 하지만, 위험성 검토, 3D 보안 인증 요청 등으로 인해 **며칠이 걸리는 경우도 있음**
    2. 시스템이 이런 케이스도 지원할 수 있어야 함
2. **지연 처리 방법 (외부 PSP 호스팅 시)**
    - PSP는 결제가 **대기(pending) 상태**임을 클라이언트에 반환하고, 클라이언트는 이를 사용자에게 표시함
    - PSP는 대기 중인 결제의 진행 상황을 추적하고, 상태가 바뀌면 등록된 **웹훅**을 통해 결제 서비스에 알림
    - 결제 서비스는 웹훅을 통해 내부 정보를 업데이트하고 고객에게 배송을 완료함
        - PSP가 웹훅 대신 결제 서비스가 주기적으로 상태를 확인(polling)하도록 요구할 수도 있음

## 3.4. 내부 서비스 간 통신

1. **동기식 통신 (HTTP)**
    - 소규모 시스템에서는 잘 작동하지만, 규모가 커지면 성능 저하, 장애 격리 곤란, 높은 결합도, 낮은 확장성 등의 단점이 발생함
2. **비동기 통신**
    - **단일 수신자:** 각 요청(메시지)은 하나의 수신자 서비스가 처리하며, 일반적으로 메시지 공유 큐를 사용해 구현함 (처리된 메시지는 큐에서 제거됨)
    - **다중 수신자:** 여러 수신자 서버가 동일한 요청을 처리함 카프카(Kafka)가 이런 시나리오를 잘 처리하며, 메시지가 바로 사라지지 않아 여러 서비스가 받아 처리할 수 있음
    - **결제 시스템의 선택:** 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에는 **비동기 통신**이 확장성과 장애 감내 능력을 높이는 더 나은 선택임

## 3.5. 결제 실패 처리

1. **결제 상태 추적:** 결제 주기의 모든 단계에서 결제 상태를 정확하게 유지하는 것이 중요함 실패 시 현재 상태를 파악해야 재시도 또는 환불 여부를 결정할 수 있음
2. **재시도 큐 및 실패 메시지 큐 활용**
    - **재시도 큐 (Retry Queue):** 네트워크 오류와 같은 **일시적이고 재시도 가능한 오류**를 보냄
    - **실패 메시지 큐 (Dead Letter Queue, DLQ):** 반복적으로 처리에 실패한 메시지를 격리하여 디버깅 및 원인 파악을 위해 사용함
3. **재시도 로직**
    - 재시도 가능 실패는 재시도 큐로 보내고, 불가능한 오류(예: 잘못된 입력)는 데이터베이스에 저장함
    - 결제 시스템은 재시도 큐의 이벤트를 다시 처리함
    - 재시도 횟수가 임계값 이내면 다시 재시도 큐로 보내고, 임계값을 넘으면 **실패 메시지 큐(DLQ)**에 넣어 별도 조사를 요청함

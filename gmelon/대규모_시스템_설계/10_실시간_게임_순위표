![image.png](attachment:21a9eade-b83d-4943-adf5-9226b76d83f2:image.png)

# 1. 문제 이해 및 설계 범위 확정

## 기능 요구사항

1. **상위 10명 플레이어 표시:** 순위표에 가장 높은 점수를 가진 10명의 플레이어를 표시함.
2. **특정 사용자 순위 표시:** 특정 사용자의 현재 순위를 표시함.
3. **주변 사용자 순위 표시 (보너스):** 특정 사용자보다 4순위 위와 아래에 있는 사용자들을 표시할 수 있어야 함.

## 비기능 요구사항 및 규모 추정

1. **실시간 갱신:** 점수 업데이트는 실시간 또는 가능한 실시간에 가깝게 순위표에 반영되어야 함.
2. **규모 확장성:** 일반적인 확장성, 가용성 및 안정성 요구사항 충족.
3. **사용자 규모:** 평균 일간 활성 사용자 수(DAU) 500만 명, 월간 활성 사용자 수(MAU) 2,500만 명 가정.
4. **최대 부하 추정:**
    1. **사용자 점수 획득 QPS:** 최대 부하 시간대(평균의 5배)를 고려하여 초당 최대 2,500회의 점수 획득 이벤트(QPS) 감당.
    2. **상위 10명 순위표 가져오기 QPS:** QPS 약 50 수준.

# 2. 개략적 설계안 제시 및 동의 구하기

## API 설계

시스템은 세 가지 주요 API를 통해 순위표 기능을 제공함.

1. **POST /v1/scores (점수 갱신):**
    - 사용자가 게임에서 승리하면 순위표에서 순위를 갱신하는 내부 API임.
    - 요청 인자는 user_id와 획득한 points
        
        ![image.png](attachment:5fc2ba8d-cbf6-40a7-80d6-3a530147ad9d:image.png)
        
2. **GET /v1/scores (상위 10명 조회):**
    - 순위표에서 상위 10명의 플레이어 목록을 가져옴.
3. **GET /v1/scores/{:user_id} (특정 사용자 순위 조회):**
    - 특정 사용자의 순위 정보를 가져옴.

## 개략적 아키텍처

![image.png](attachment:e73bdf75-5128-4c8c-a51b-f48468a8caad:image.png)

1. **서비스 구성:** 설계안은 **게임 서비스**와 **순위표 서비스** 두 가지 서비스로 구성됨.
2. **점수 갱신 흐름:**
    1. 사용자가 승리하면 클라이언트가 게임 서비스에 요청함.
    2. 게임 서비스는 승리의 유효성을 확인한 후 순위표 서비스에 점수 갱신을 요청함.
    3. 순위표 서비스는 순위표 저장소의 사용자 점수를 갱신함.
3. **순위표 조회 흐름:** 클라이언트가 순위표 서비스에 직접 요청하여 상위 10명 순위표나 해당 사용자 순위를 가져옴.
4. **보안 고려사항:** 클라이언트가 점수를 직접 설정하는 방식은 중간자 공격에 취약하므로, 점수 설정은 반드시 서버가 담당해야 함.
    
    ![image.png](attachment:0fa29c0c-2f3e-4f1b-8f46-1daadfdcd66d:image.png)
    
5. **메시지 큐 (선택 사항):** 게임 점수 데이터가 분석, 푸시 알림 등 여러 기능을 지원해야 한다면 카프카(Kafka)와 같은 메시지 큐를 도입하여 여러 서비스가 동일한 데이터를 소비하도록 하는 방안 고려.
    - [ ]  다른 서비스에서 사용하지 않더라도 유량 제어 목적으로 사용하면 안 되나?
    
    ![image.png](attachment:2d588262-ed9a-4a00-8647-e5fab746052b:image.png)
    

## 데이터 모델: 관계형 데이터베이스 (RDS)의 한계

1. **RDS 모델:** 사용자 ID와 점수 열을 가진 `leaderboard` 테이블을 만들어 점수에 따라 내림차순으로 정렬하여 순위를 결정함.
    
    ![image.png](attachment:be68fcc9-2792-40b2-aea9-75d42f142841:image.png)
    
2. **점수 갱신:** 새로운 레코드를 삽입하거나, 기존 레코드의 점수를 `UPDATE` 명령으로 1씩 증가시킴.
    
    ![image.png](attachment:974602a4-a350-4269-895b-9ea57b19e40f:image.png)
    
3. **순위 검색:** 순위를 가져오려면 테이블을 점수 기준으로 정렬한 후 순위를 매겨야 함.
    
    ![image.png](attachment:c78daa52-f1fb-4dc2-a518-e8bd021c0f67:image.png)
    
4. **RDS의 문제점 (규모 확장성 부족):**
    1. **성능 저하:** 레코드가 수백만 개로 많아지면 순위를 매기기 위해 전체 테이블을 정렬해야 하므로 성능이 수십 초 정도로 나빠짐.
    2. **실시간성 미흡:** 지속적으로 데이터가 변경되므로 캐시 도입이 불가능하며, 실시간성을 요구하는 애플리케이션에 부적합함.
    3. **특정 사용자 순위 조회 어려움:** `LIMIT` 절을 사용해도 특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 하므로 성능이 떨어짐.
- [ ]  RDS 를 사용하는 다른 방법은 불가능한가?
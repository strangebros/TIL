![image.png](attachment:21a9eade-b83d-4943-adf5-9226b76d83f2:image.png)

# 1. 문제 이해 및 설계 범위 확정

## 기능 요구사항

1. **상위 10명 플레이어 표시:** 순위표에 가장 높은 점수를 가진 10명의 플레이어를 표시함.
2. **특정 사용자 순위 표시:** 특정 사용자의 현재 순위를 표시함.
3. **주변 사용자 순위 표시 (보너스):** 특정 사용자보다 4순위 위와 아래에 있는 사용자들을 표시할 수 있어야 함.

## 비기능 요구사항 및 규모 추정

1. **실시간 갱신:** 점수 업데이트는 실시간 또는 가능한 실시간에 가깝게 순위표에 반영되어야 함.
2. **규모 확장성:** 일반적인 확장성, 가용성 및 안정성 요구사항 충족.
3. **사용자 규모:** 평균 일간 활성 사용자 수(DAU) 500만 명, 월간 활성 사용자 수(MAU) 2,500만 명 가정.
4. **최대 부하 추정:**
    1. **사용자 점수 획득 QPS:** 최대 부하 시간대(평균의 5배)를 고려하여 초당 최대 2,500회의 점수 획득 이벤트(QPS) 감당.
    2. **상위 10명 순위표 가져오기 QPS:** QPS 약 50 수준.

# 2. 개략적 설계안 제시 및 동의 구하기

## API 설계

시스템은 세 가지 주요 API를 통해 순위표 기능을 제공함.

1. **POST /v1/scores (점수 갱신):**
    - 사용자가 게임에서 승리하면 순위표에서 순위를 갱신하는 내부 API임.
    - 요청 인자는 user_id와 획득한 points
        
        ![image.png](attachment:5fc2ba8d-cbf6-40a7-80d6-3a530147ad9d:image.png)
        
2. **GET /v1/scores (상위 10명 조회):**
    - 순위표에서 상위 10명의 플레이어 목록을 가져옴.
3. **GET /v1/scores/{:user_id} (특정 사용자 순위 조회):**
    - 특정 사용자의 순위 정보를 가져옴.

## 개략적 아키텍처

![image.png](attachment:e73bdf75-5128-4c8c-a51b-f48468a8caad:image.png)

1. **서비스 구성:** 설계안은 **게임 서비스**와 **순위표 서비스** 두 가지 서비스로 구성됨.
2. **점수 갱신 흐름:**
    1. 사용자가 승리하면 클라이언트가 게임 서비스에 요청함.
    2. 게임 서비스는 승리의 유효성을 확인한 후 순위표 서비스에 점수 갱신을 요청함.
    3. 순위표 서비스는 순위표 저장소의 사용자 점수를 갱신함.
3. **순위표 조회 흐름:** 클라이언트가 순위표 서비스에 직접 요청하여 상위 10명 순위표나 해당 사용자 순위를 가져옴.
4. **보안 고려사항:** 클라이언트가 점수를 직접 설정하는 방식은 중간자 공격에 취약하므로, 점수 설정은 반드시 서버가 담당해야 함.
    
    ![image.png](attachment:0fa29c0c-2f3e-4f1b-8f46-1daadfdcd66d:image.png)
    
5. **메시지 큐 (선택 사항):** 게임 점수 데이터가 분석, 푸시 알림 등 여러 기능을 지원해야 한다면 카프카(Kafka)와 같은 메시지 큐를 도입하여 여러 서비스가 동일한 데이터를 소비하도록 하는 방안 고려.
    - [ ]  다른 서비스에서 사용하지 않더라도 유량 제어 목적으로 사용하면 안 되나?
    
    ![image.png](attachment:2d588262-ed9a-4a00-8647-e5fab746052b:image.png)
    

## 데이터 모델: 관계형 데이터베이스 (RDS)의 한계

1. **RDS 모델:** 사용자 ID와 점수 열을 가진 `leaderboard` 테이블을 만들어 점수에 따라 내림차순으로 정렬하여 순위를 결정함.
    
    ![image.png](attachment:be68fcc9-2792-40b2-aea9-75d42f142841:image.png)
    
2. **점수 갱신:** 새로운 레코드를 삽입하거나, 기존 레코드의 점수를 `UPDATE` 명령으로 1씩 증가시킴.
    
    ![image.png](attachment:974602a4-a350-4269-895b-9ea57b19e40f:image.png)
    
3. **순위 검색:** 순위를 가져오려면 테이블을 점수 기준으로 정렬한 후 순위를 매겨야 함.
    
    ![image.png](attachment:c78daa52-f1fb-4dc2-a518-e8bd021c0f67:image.png)
    
4. **RDS의 문제점 (규모 확장성 부족):**
    1. **성능 저하:** 레코드가 수백만 개로 많아지면 순위를 매기기 위해 전체 테이블을 정렬해야 하므로 성능이 수십 초 정도로 나빠짐.
    2. **실시간성 미흡:** 지속적으로 데이터가 변경되므로 캐시 도입이 불가능하며, 실시간성을 요구하는 애플리케이션에 부적합함.
    3. **특정 사용자 순위 조회 어려움:** `LIMIT` 절을 사용해도 특정 사용자의 순위를 알아내려면 기본적으로 전체 테이블을 훑어야 하므로 성능이 떨어짐.
- [ ]  RDS 를 사용하는 다른 방법은 불가능한가?

## 데이터 모델: 레디스 정렬 집합 (`Redis Sorted Set`) 활용

**레디스 정렬 집합의 특징**

1. **고성능:** 메모리 기반 키-값 저장소로, 빠른 읽기 및 쓰기 가능.
2. **정렬 집합 (Sorted Set):** 순위표 시스템 설계에 이상적인 자료형으로, 각 원소(사용자 ID)는 점수(Score)에 연결되어 있으며, 점수를 기준으로 오름차순 정렬됨.
    
    ![image.png](attachment:6d47893b-09cb-433e-836f-cb38f0080ed5:image.png)
    
3. **내부 구조:** 정렬 집합은 내부적으로 **해시 테이블** (사용자 점수 저장)과 **스킵 리스트** (정렬 및 빠른 검색)를 사용함.
4. **스킵 리스트:** 정렬된 연결 리스트에 다단계 색인(index)을 두어 검색, 삽입, 삭제 연산의 시간 복잡도를 `O(log(n))` 으로 개선함.
    
    ![image.png](attachment:b6fe952e-f143-485d-9d1e-3021f37a42fd:image.png)
    
    ![image.png](attachment:623dbf90-e0ad-46a8-b6f3-ef3556399616:image.png)
    
- [ ]  **RDS로 질의하면 왜 성능이 안 좋은지**
    
    ```sql
    SELECT *,(SELECT COUNT(*) FROM leaderboard lb2
    WHERE lb2.score >= lb1.score) RANK
    FROM leaderboard lb1
    WHERE lb1.user_id = {:user_id};
    ```
    

**레디스 정렬 집합을 사용해 요구사항 구현하기**

1. **점수 갱신 (ZADD/ZINCRBY):**
    - `ZADD`는 기존 사용자의 점수를 업데이트하거나 새로운 사용자를 삽입함.
    - `ZINCRBY`는 사용자 점수를 지정된 값만큼 증가시킴.
    - 실행 시간은 `O(log(n))`
    
    ```sql
    ZINCRBY leaderboard_feb_2021 1 'mary1934'
    ```
    
    ![image.png](attachment:e8550f6f-3f53-4a3e-a665-303e21aff1a9:image.png)
    
2. **상위 N명 조회 (ZREVRANGE):**
    - `ZREVRANGE`를 호출하여 내림차순으로 정렬된 사용자 중 특정 범위(예: 0부터 9까지)에 드는 사용자 목록과 점수를 가져옴.
    - 실행 시간은 `O(log(n) + m)` (m은 가져올 항목 수)
    
    ```sql
    ZREVRANGE leaderboard_feb_2021 0 9 WITHSCORES
    ```
    
    ![image.png](attachment:d9a92942-6c05-422f-ae01-55bb236b24ba:image.png)
    
3. **특정 사용자 순위 조회 (ZREVRANK):**
    - `ZREVRANK`를 호출하여 내림차순 정렬을 기준으로 특정 사용자의 위치(순위)를 가져옴.
    - 실행 시간은 `O(log(n))`
    
    ```sql
    ZREVRANK leaderboard_feb_2021 1 'mary9341'
    ```
    
    ![image.png](attachment:c22a30b6-313d-49e9-af8e-439748643558:image.png)
    
4. **주변 사용자 조회:** 특정 사용자의 순위(랭크)를 기준으로 `ZREVRANGE`를 활용하여 전/후 순위 사용자 목록을 얻을 수 있음.
    
    ```sql
    ZREVRANGE leaderboard_feb_2021 357 365
    ```
    
    ![image.png](attachment:17403a76-7e5a-48e2-92d5-ebf116b1e052:image.png)
    

## 저장소 요구사항 및 영속성

1. **저장 용량 추정:** MAU 2,500만 명 기준, 순위표 한 항목당 26바이트 가정 시 총 약 650MB의 저장공간 필요.
2. **단일 서버 가능성:** 스킵 리스트 오버헤드를 고려해 메모리 사용량을 두 배로 늘려도 최신 레디스 서버 한 대로 충분히 데이터 저장 가능.
3. **CPU/I/O 부하:** 최대 갱신 QPS 2,500/초는 단일 레디스 서버로 감당 가능한 부하
4. **영속성 (Persistence):** 레디스 노드 장애에 대비하여 데이터를 디스크에 영속적으로 보관하는 옵션 지원. 일반적으로 읽기 사본(Read Replica)을 두어 주 서버 장애 시 승격시키는 방식으로 구성함.
    - [ ]  레디스에서, 디스크에 영속되기 전에 죽으면? 영속시키고 나서 200 을 때리나? 그럼 더 이상 메모리 db 가 아니게 되니깐 성능이 많이 떨어질 것 같은데?
5. **보조 데이터베이스 (MySQL):** 레디스 순위표 복구 및 다른 게임 기능(경연 기록) 구현을 위해 사용자 ID, 점수, 타임스탬프 등의 정보를 MySQL에 저장
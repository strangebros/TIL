## 궁금증 🤔

회사에서 최근 카프카를 도입했는데, 동기식 호출 대신 카프카를 쓰면 성능이 좋아진다는 말을 자주 듣는다. 근데 정확히 어떤 원리인지 궁금해졌다.

특히 **컨슈머가 자신이 처리할 수 있는 만큼만 메시지를 가져간다**는 게 어떻게 동작하는건지 이해하고 싶다.

## 1. Pull 방식

카프카는 **Pull 모델**을 쓴다.

컨슈머가 요청하면 브로커가 메시지를 주는 방식이다. 컨수머는 기존 메서지가 처리 완료되면 다시 브로커에게 메시지를 요청한다.

## 컨슈머 조절 방법

### 기본적인 방법

```java
Properties props = new Properties();
props.put("max.poll.records", 100); // 한 번에 100개만 달라고 함

while (true) {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(1000));
    
    for (ConsumerRecord<String, String> record : records) {
        processMessage(record); // 하나씩 처리
    }
    
    consumer.commitSync(); // 다 처리했다고 알림
}
```

이렇게 하면 컨슈머가 100개 처리하는데 10초 걸린다면, 10초마다 100개씩만 요청한다.

### 추가 설정들

```properties
fetch.min.bytes=1048576    # 최소 1MB 쌓일때까지 대기
fetch.max.wait.ms=500      # 단, 최대 500ms만 대기
```

위 설정으로 작은 메시지들을 모아서 배치로 처리할 수 있다.

## 여러 가지 처리 방법들

### 1. Spring이 제공하는 추상화 활용 (일반적)
```java
@KafkaListener(topics = "order-events")
public void handleEvents(List<OrderEvent> events) {
    
    for (OrderEvent event : events) {
        processOrder(event); // 10초 소요
    }
    
    // 10초 후에야 다음 poll() 실행됨
    // 자연스럽게 처리 속도 조절
}
```

#### 백프레셔
생산자가 보내는 속도 > 컨슈머가 처리하는 속도 일 때 발생하는 상황을 제어하는 메커니즘.
```
// Backpressure 가 없는 경우
Producer(1000/sec) -> Consumer(100/sec) -> 💥 시스템 다운

// Backpressure 를 적용한 경우
Producer(1000/sec) -> Kafka Broker -> Consumer(100/sec) ✅
                       (큐 역할)      (안전하게 처리 가능)
```

### 2. 임의로 sleep() 을 거는 방법
* https://techblog.woowahan.com/20156/
  * db 등 다른 자원에 제약이 걸려있을 때 유용한 방법
```java
@Component
public class FlowControlConsumer {

    private final KafkaListenerEndpointRegistry registry;
    
    @KafkaListener(topics = "order-events", id = "orderConsumer")
    public void handleEvents(List<OrderEvent> events) {
        
        if (isSystemOverloaded()) {
            // 컨슈머 일시정지
            registry.getListenerContainer("orderConsumer").pause();
            
            // 별도 스레드에서 복구 로직 실행
            scheduleResume();
            return;
        }
        
        events.forEach(this::processOrder);
    }
}
```

## 2. 컨슈머 그룹과 파티션

카프카의 특장점은 **수평 확장**이 쉽다는 것.

파티션이 3개 있으면 컨슈머도 최대 3개까지 붙일 수 있다 (같은 컨수머 그룹 내에서). 각 컨수머가 각 파티션을 담당한다. 이때 각 컨슈머는 독립적으로 자신의 처리 속도에 맞춰 메시지를 가져가기 때문에, 한 컨슈머가 느려도 다른 컨슈머들은 영향받지 않는다. 또한 컨슈머 그룹 내에서 리밸런싱이 발생하면 파티션 할당이 자동으로 재조정되어, 장애가 발생한 컨슈머가 담당하던 파티션을 다른 컨슈머가 이어받을 수 있다.
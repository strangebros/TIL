### 카프카 컨슈머 개념과 컨슈머 그룹
* 카프카 컨슈머는 토픽의 파티션으로부터 메시지를 읽어오는 애플리케이션
* 컨슈머 그룹은 동일한 group.id를 공유하는 컨슈머들의 집합
  * 토픽의 파티션들을 분담해서 처리함
  * 각 파티션은 컨슈머 그룹 내에서 단 하나의 컨슈머에게만 할당됨
  * 이를 통해 메시지 처리 순서가 보장됨

### 컨슈머 구성과 파티션 재할당
* 리밸런싱이 발생하는 케이스들
  * 컨슈머가 그룹에 합류하거나 떠날 때
  * 토픽에 파티션이 추가될 때
  * 컨슈머가 비정상적으로 종료될 때
* 리밸런싱 과정에서 파티션이 컨슈머들 사이에 재할당
* 그룹 코디네이터가 이를 관리하고, 리밸런싱 중에는 잠시 메시지 소비 중단 가능

### 컨슈머 API 사용법
* 기본적인 컨슈머 생성과 구독 과정
  1. Properties 설정 (bootstrap.servers, group.id, key/value deserializer 등)
  2. KafkaConsumer 인스턴스 생성
  3. subscribe() 메서드로 토픽 구독
  4. poll() 루프를 통한 메시지 소비
  5. 리소스 정리

### 오프셋 관리
* 오프셋: 컨슈머가 어디까지 메시지를 읽었는지 추적하는 위치 정보
* 커밋 방식 종류
  1. **자동 커밋**: 간편하지만 메시지 손실이나 중복 위험 있음
  2. **동기 커밋**: 안전하지만 성능 저하 가능
  3. **비동기 커밋**: 성능은 좋지만 복잡도 증가
  4. **특정 오프셋 커밋**: 세밀한 제어 가능, 배치 처리할 때 유용

### 리밸런스 리스너
* ConsumerRebalanceListener를 구현 -> 리밸런싱 전후에 특별한 처리 가능
* 주요 메서드
  * onPartitionsRevoked(): 파티션이 재할당되기 전에 호출
  * onPartitionsAssigned(): 새로운 파티션이 할당된 후 호출
* 파티션 할당 변경 시 오프셋 커밋이나 상태 정리 등의 작업 수행 가능

### 특정 오프셋에서 소비 시작
* seek() 메서드를 사용해서 특정 오프셋부터 메시지 읽기 가능
  * seekToBeginning(): 처음부터 시작
  * seekToEnd(): 끝부터 시작
* 재처리나 특정 시점 복구할 때 유용

### 폴링 루프 종료
* 안전한 컨슈머 종료 방법
  * wakeup() 메서드를 사용해서 poll() 에서 WakeupException 발생
  * shutdown hook에서 wakeup() 호출
  * finally 블록에서 close() 호출해서 리소스 정리

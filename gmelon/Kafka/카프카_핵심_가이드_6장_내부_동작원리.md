### 클러스터 멤버십
* 카프카는 주키퍼를 사용해서 브로커들의 리스트를 관리
  * 각 브로커는 시작할 때 주키퍼에 자신을 등록
  * 임시 노드를 생성해서 브로커 ID와 네트워크 정보 저장
  * 브로커가 중단되면 임시 노드가 자동으로 삭제됨
* 컨트롤러가 주키퍼 워치를 통해 브로커 상태 변화를 감지
  * 새 브로커 추가나 기존 브로커 장애를 즉시 인지할 수 있다.

### 컨트롤러
* 컨트롤러는 일반 브로커 중 하나가 추가로 담당하는 역할
  * 파티션 리더 선출 책임
  * 토픽 생성/삭제 시 파티션과 레플리카 할당 관리
  * 브로커 장애 시 영향받는 파티션들의 새 리더 선출
* 컨트롤러 선출 과정
  * 클러스터 시작 시 모든 브로커가 주키퍼에 컨트롤러 노드 생성 시도
  * 먼저 성공한 브로커가 컨트롤러가 됨
  * 나머지 브로커들은 컨트롤러 노드에 워치 설정
* 컨트롤러 장애 시 자동으로 새 컨트롤러 선출됨

### 복제(Replication)
* 각 파티션은 하나의 리더와 0개 이상의 팔로워 레플리카를 가짐
  * 리더는 모든 읽기/쓰기 요청 처리
  * 팔로워는 리더로부터 메시지를 복제만 함
* ISR(In-Sync Replicas): 리더와 동기화된 레플리카 집합
  * 리더의 모든 메시지를 복제한 팔로워들
  * `replica.lag.time.max.ms` 동안 fetch 요청이 없으면 ISR에서 제외
  * 리더 장애 시 ISR 중에서만 새 리더 선출 가능

### 요청 처리
* 브로커가 처리하는 주요 요청 타입들
  * Produce 요청: 프로듀서가 메시지 전송
  * Fetch 요청: 컨슈머나 팔로워 브로커가 메시지 읽기
  * Metadata 요청: 클러스터 정보 조회
* 요청 처리 흐름
  1. 네트워크 스레드가 요청을 받아 요청 큐에 넣음
  2. I/O 스레드가 요청을 처리하고 응답 큐에 결과 저장
  3. 네트워크 스레드가 응답을 클라이언트에 전송
* `zero-copy` 최적화로 디스크에서 네트워크로 직접 데이터 전송

### Produce 요청 처리
* acks 설정에 따른 동작 차이
  * acks=0: 응답 기다리지 않음, 메시지 손실 가능
  * acks=1: 리더에 쓰기 완료 후 응답
  * acks=all: 모든 ISR에 복제 완료 후 응답
* 리더는 메시지를 로컬 디스크에 쓴 후 복제 대기
* `min.insync.replicas` 설정으로 최소 복제 수 보장

### Fetch 요청 처리
* 컨슈머는 오프셋을 지정해서 특정 위치부터 메시지 fetch
* 팔로워도 리더에게 fetch 요청을 보내서 복제 수행
  * 팔로워는 자신의 현재 오프셋부터 계속 요청
  * 이를 통해, 리더는 팔로워의 복제 진행 상황을 추적
* 효율성을 위한 설정들
  * `fetch.min.bytes`: 최소 데이터 크기까지 대기
  * `fetch.max.wait.ms`: 최대 대기 시간
* 바운드 체크로 잘못된 오프셋 요청 방지

### 물리적 저장소
* 파티션은 세그먼트 파일들로 구성
  * 활성 세그먼트: 현재 쓰기가 진행되는 세그먼트
  * 세그먼트 크기나 시간 제한 도달 시 새 세그먼트 생성
* 각 세그먼트는 로그 파일과 인덱스 파일로 구성
  * 로그 파일: 실제 메시지 데이터
  * 인덱스 파일: 오프셋과 파일 위치 매핑
  * 타임스탬프 인덱스: 시간 기반 검색 지원
* 파일 관리와 압축
  * `log.segment.bytes` 로 세그먼트 크기 제어
  * 오래된 세그먼트는 보관 정책에 따라 삭제나 압축

### 로그 압축(Log Compaction)
* 키 기반으로 각 키의 최신 값만 유지하는 방식
  * 삭제 대신 압축을 통해 저장 공간 절약
  * 키별 최종 상태를 영구 보존할 때 유용
* 압축 프로세스
  1. 클리너 스레드가 더티 비율이 높은 파티션 선택
  2. 오프셋 맵을 생성해서 각 키의 최신 오프셋 추적
  3. 세그먼트를 읽으면서 최신 메시지만 새 세그먼트에 복사
* tombstone 메시지(null 값)로 키 삭제 표시
  * `delete.retention.ms` 동안 유지 후 실제 삭제

#### 삭제 요청 처리
* 파일 삭제는 비용이 큰 작업이라 바로 삭제하지 않음
  * 삭제 대상 세그먼트를 `.deleted` 확장자로 이름 변경
  * 백그라운드 스레드가 나중에 실제 삭제 수행
* 토픽 삭제 시에도 유사한 방식으로 처리
  * 먼저 메타데이터에서 삭제 표시
  * 실제 데이터는 비동기로 정리
## 개요

- 아파치 카프카는 신뢰성 있는 데이터 전달에 있어서, 매우 유연
- 때문에 실제로는 그렇지 않은 지점에서 신뢰성이 높다고 착각하여 문제를 초래하기 쉬움

## 7.1 신뢰성 보장

> **보장**
→ 서로 다른 상황에서도 시스템이 지킬 것이라 보장되는 행동
> 

### 카프카가 보장하는 것

1. 파티션 내 메시지들 간 순서 보장
    1. 동일 프로듀서가 동일 파티션에 쓴 경우, 나중에 쓰여진 메시지의 offset 이 이전에 쓰여진 메시지보다 큼을 보장
2. 클라이언트가 쓴 메시지는 모든 ISR 파티션에 쓰여진 뒤에야 `커밋` 된 것으로 간주됨
3. `커밋`된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않음
4. 컨슈머는 `커밋`된 메시지만 읽을 수 있음

## 7.2 복제

> 카프카의 신뢰성 보장의 핵심
> 
- 하나의 메시지를 여러 개의 레플리카에 씀으로써 크래시가 나더라도 메시지의 지속성을 유지

### 6장 복습

- 각 카프카 토픽은 파티션으로 구성되며, 하나의 파티션은 하나의 디스크에 저장됨
- 카프카는 파티션 내 이벤트 순서를 보장하며, 파티션은 온라인 또는 오프라인 상태일 수 있음
- 각 파티션은 여러 레플리카를 가질 수 있으며, 그 중 하나가 리더가 됨
- 모든 이벤트는 리더 레플리카에 쓰여지고 일반적으로 리더에서 읽혀짐
- 다른 레플리카들은 리더와 동기화를 유지하며 최신 이벤트를 복사함
- 리더가 작동 불능 상태가 되면, ISR 중 하나가 새 리더가 됨

### ISR 판단 기준

- 주키퍼와의 활성 세션 존재 (최근 n(6)초 사이에 주키퍼로 하트비트 전송)
- 최근 n(10)초 사이에 리더로부터 메시지를 읽어옴
- 최근 n(10)초 사이에 리더로 부터 읽어온 메시지들이 가장 최근 메시지임
    - 즉, 최근 n초 사이에 랙이 없었던 적이 최소 한번은 있어야 함

### ISR/OSR 이 성능에 주는 영향

- 동기화가 살짝 늦은 ISR 은 프로듀서와 컨슈머를 느리게 만듦
    - 모든 ISR 가 메시지를 받아야 메시지가 `커밋` 되기 때문
- 오히려 ISR → OSR 이 되면 동기화가 밀리긴 하지만 성능에 영향을 주진 않는다
    - 다만, 데이터 유실 가능성은 높아짐

## 7.3 브로커 설정

> 신뢰성 관련된 카프카의 작동을 변경시키는 매개변수는 3개

1. 브로커 단위 적용 → 시스템 안의 모든 토픽들에 적용
2. 토픽 단위 적용 → 특정 토픽에만 적용
> 

### 복제 팩터

> 토픽 단위 → replication.factor
브로커 단위 → default.replication.factor
> 
- 복제 팩터가 N 이면, N-1 개의 브로커가 중단되어도 토픽의 데이터를 읽거나 쓸 수 있음
    - 클수록 가용성, 신뢰성 증가 & 장애 발생 가능성 감소
    - 클수록 필요한 디스크 공간이 비례하여 증가

### 적절한 복제 팩터 값 선택을 위한 고려 사항

1. 가용성
    1. 레플리카가 많을 수록 가용성 증가
2. 지속성
    1. 레플리카가 많을 수록 데이터의 지속성 증가
    2. 레플리카가 하나뿐이고 해당 브로커가 죽으면, 모든 데이터는 유실됨
3. 처리량
    1. 레플리카가 추가될 때마다 브로커간 트래픽 증가
4. 종단 지연
    1. 메시지 커밋을 위해 모든 ISR 레플리카에 메시지를 복제해야 하므로,
    2. 복테 팩터가 클수록 프로듀서-컨슈머 간 종단 지연은 증가한다
5. 비용
    1. 중요하지 않은 데이터데 대해 복제 팩터를 적게 잡아주는 가장 큰 이유..
    2. N 이 클 수록 네트워크/저장소 비용이 증가하기 때문 (당연)
6. 레플리카의 위치
    1. 서로 다른 브로커라고 해도, 동일한 랙(가용 영역, AZ) 에 위치한 경우 한번에 모든 파티션 레플리카가 사용 불가능해질 수 있음
    2. 브로커들을 서로 다른 랙에 배치 후 `broker.rack` 을 다르게 잡아주면 카프카는 파티션 레플리카가 서로 다른 rack 에 배치되도록 한다.

### 언클린 리더 선출

> 브로커 단위에서만 가능 → unclean.leader.election.enable
기본값: false
> 
- 리더가 작동 불능에 빠졌다!
    - 그런데 이 리더 외에 ISR 이 하나도 없다면 어떻게 될까?
- 이게 가능한 케이스 2가지
    1. 파티션에 3개의 레플리카가 있고, 팔로워 2개가 작동 불능에 빠진 경우
        - 리더만 인-싱크 레플리카로 남아 계속 메시지를 받음
        - 이후 리더마저 작동 불능 시, 아웃-오브-싱크 레플리카 중 하나가 시작되면 해당 파티션의 유일한 사용 가능 레플리카가 됨
    2. 파티션에 3개의 레플리카가 있고, 네트워크 문제로 팔로워 2개의 복제 작업이 지연된 경우
        - 복제는 계속되지만 팔로워들은 더 이상 인-싱크 상태가 아님복제는 계속되지만 팔로워들은 더 이상 인-싱크 상태가 아님
        - 리더가 유일한 인-싱크 레플리카로 메시지를 계속 받음리더가 유일한 인-싱크 레플리카로 메시지를 계속 받음
        - 리더가 작동 불능 시, 오직 아웃-오브-싱크 레플리카만 리더가 될 수 있음리더가 작동 불능 시, 오직 아웃-오브-싱크 레플리카만 리더가 될 수 있음
- 쉽지 않은 결정을 해야 함
    1. ISR 만 리더로 사용
        1. 마지막 ISR 이 복구될 때 까지 하염없이 기다려야 함
    2. OSR (0~100 만 가짐) 도 리더로 사용
        1. 당장 동작 가능하지만,
        2. OSR 이 따라잡지 못한 메시지(e.g. 100~200)는 유실됨
            1. 기존 ISR 이 복구되면 새로운 리더 (전 OSR) 이 가지고 있지 않은 메시지는 지워버림
        3. 새로운 100~200 offset 을 가진 메시지에 OSR 에 쓰여짐
- 기본 값은 `false` 이니 만큼, 정말 긴급하게 컨슈머를 동작시켜야 할 때만 고민해서 사용하고 다시 false 로 돌려두자

### 최소 인-싱크 레플리카

> 토픽, 브로커 → min.insync.replicas
> 
- ISR 이 현재 1개만 존재한다면 `ack=all` 옵션을 사용한다고 해도, 오직 하나의 파티션 레플리카에 쓰게 됨
- 이때 `min.insync.replicas` 을 `2` 이상으로 잡으면 현재 ISR 가 `2` 개 이상일 때만 프로듀서가 메시지를 쓸 수 있다
    - 그렇지 않으면 `NotEnoughReplicasException` 발생

### 레플리카를 ISR 상태로 유지

- 레플리카를 ISR 로 볼지말지에 대한 민감도 설정 옵션이 존재
    1. [`zookeeper.session.timeout.ms`](http://zookeeper.session.timeout.ms)
        1. 카프카 브로커가 주키퍼로 하트비트 전송을 멈출 수 있는 최대 시간
        2. 2.5.0 버전에서 기본값이 18초로 증가
        3. 무작위적인 변동에 영향을 받지 않을 만큼 높게, 하지만 실제로 멈추면 탐지가 가능할 정도로는 낮게 설정되어야 함
    2. `replica.lag.time.max.ms`
        1. 이 시간 보다 더 오래 리더로부터 데이터를 읽지 못하거나, 최신 메시지를 따라잡지 못하면 OSR 이 된다
        2. 2.5.0 버전에서 기본값이 30초로 증가
        3. 이 값은 그대로 컨슈머의 최대 지연에도 영향을 줌

### 디스크에 저장하기

- 카프카는 메시지 `커밋` 시 flush 여부는 체크하지 않음
    - 리더의 디스크에 실제로 쓰여지는 것 보다, 서로 다른 랙에 위치한 브로커의 레플리카에 복제되는게 더 안전하다는 판단에 기반함
- 관련 옵션들
    - `flush.messages`
        - 디스크에 저장되지 않은 최대 메시지 수 지정
    - `flush.ms`
        - 얼마나 자주 디스크에 메시지를 저장할지를 지정

## 7.4 신뢰성 있는 시스템에서 프로듀서 사용하기

- 브로커 설정이 잘 되어 있어도, 프로듀서가 신뢰성 높게 설정되지 않으면 시스템 전체로선 여전히 데이터 유실 가능
- 두가지 예시
    1. `acks=1` 설정 시, 리더에 작성 후 복제되기 전 크러시가 발생하면 메시지 유실 가능
    2. `acks=all` 설정, 리더에서 크래시 발생 후 아직 선출 중 상태
        1. 프로듀서는 `Leader not Available` 응답 수신
        2. 이에 대한 적절한 재시도를 하지 않으면, 메시지는 유실된다
- 즉, 두 가지를 신경써야 한다
    - 적절한 acks 설정 사용
    - 설정과 코드 모두에서 에러를 올바르게 처리

### 7.4.1 응답 보내기

- `acks` 설정을 적절하게 선택하라
1. acks=0
    1. 응답을 기다리지 않음. 보내면 끝
2. acks=1
    - 리더만 받으면 응답.
3. acks=all
    1. 모든 ISR 이 받아야 (`커밋` 시점) 응답

### 7.4.2 프로듀서 재시도 설정하기

- 에러 처리는 두 부분으로 나눠짐
1. 프로듀서가 자동으로 처리
    1. 재시도 수를 기본 설정 값 (MAX_INT) 로 설정하고,
    2. 메시지 전송을 포기할 때까지 대기 가능한 시간 ([`delivery.timeout.ms`](http://delivery.timeout.ms)) 을 최대로 잡아주기
    3. 이때 메시지는 항상 성공적으로 쓰여지지만, 중복은 가능하다

### 7.4.3 추가적인 에러 처리

1. 개발자들이 처리
    1. 예제
        1. 메시지 크기, 인가 관련 재시도 불가능 에러
        2. 직렬화등 브로커에 메시지가 전송되기 전에 발생한 에러
        3. 프로듀서가 모든 재전송 시도를 소진했거나, 재시도 과정에서 프로듀서가 사용하는 가용 메모리가 가득차서 발생
        4. 타임아웃
    2. 선택 가능한 옵션들
        1. 폐기?
        2. 로깅?
        3. 백프레셔 적용? → 잠시 메시지 전송을 멈추기
        4. 로컬 디스크에 저장?

## 7.5 신뢰성 있는 시스템에서 컨슈머 사용하기

- 기본 동작
    - 컨슈머는 일관성이 보장되는 데이터만 읽는다 (`커밋`된 데이터)
- 오프셋이 언제 어떻게 커밋되는지가 중요하다
    - A 컨슈머 크래시 → B 컨슈머가 이어서 수행되는 경우
    - A 컨슈머 크래시 → A 컨슈머가 다시 실행되어 이어서 수행되는 경우
    - 위 2가지 케이스에, 이전 컨슈머가 어디까지 처리했는지를 정확하게 알아야 누락되는 메시지가 없기 때문
- 커밋된 메시지 vs 커밋된 오프셋
    - 메시지: 모든 ISR 에 쓰여져 컨슈머가 읽을 수 있는 메시지
    - 오프셋: 컨슈머가 특정 파티션 - 오프셋까지의 모든 메시지를 받아서 처리했는지를 알리기 위해 카프카에 보낸 오프셋

### 7.5.1 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

1. group.id
    1. 컨슈머 그룹에 대한 식별자로,
    2. 서로 같은 id 를 갖는 컨슈머는 토픽 메시지 중 서로 다른 부분집합을 읽게 됨
2. auto.offset.reset
    1. 컨슈머가 처음부터 시작되었거나 컨슈머가 오랫동안 읽지 않아 오프셋의 레코드가 이미 브로커에서 삭제된 경우 등의 상황에서, 컨슈머가 어떻게 동작할 것인가?
    2. earliest
        1. 파티션의 맨 앞에서부터 읽기 시작
        2. 매우 많은 메시지의 중복 발생, 유실 최소화
    3. latest
        1. 파티션의 끝에서부터 읽기 시작
        2. 중복 X, 일부 메시지 누락
3. enable.auto.commit
    1. 오프셋을 컨슈머가 알아서 커밋? ↔ 코드에서 직접 커밋?
    2. true 설정 시 장점: 실수로 오프셋을 커밋하지 않는 상황을 방지해줌
    3. true 설정 시 단점: 비동기 등으로 메시지를 ‘처리’ 하는 경우에, 실제로는 처리되지 않았지만 오프셋이 커밋되는 것을 막을 수 없음
        1. 이 경우엔 직접 커밋해주어야 한다.
4. auto.commit.interval.ms
    1. `enable.auto.commit = true` 인 경우의 커밋 주기 설정

### (4장 복습) 리밸런싱이 발생했을 때 컨슈머의 멈춤을 최소화하기 위해서는,,

### 7.5.2 컨슈머에서 명시적으로 오프셋 커밋하기

> `enable.auto.commit = false` 로 사용하기로 마음먹은 케이스
> 
1. 메시지 처리 먼저, 오프셋 커밋은 나중에하자
2. 커밋 빈도는 성능과 크래시 발생 시 중복 개수 사이의 트레이드오프이다
    1. 커밋 작업은 상당한 성능 오버헤드를 수반
    2. 메시지를 읽어올 때마다 커밋하는 방식은 거의 사용 불가능
    3. 성능 ↔ 중복 요구사항 사이에서 타협점을 찾아야
3. 정확한 시점에 정확한 오프셋을 커밋하자
    1. 처리 완료된 메시지를 커밋해야 한다
    2. 읽어온 메시지를 커밋하면 안 된다.
4. 리밸런스
    1. 컨슈머 리밸런스는 발생할 수 있다는 것과, 이걸 적절히 처리해 줄 필요가 있다는 점을 기억해야 함
    2. 일반적으론, 할당된 파티션이 해제되기 전에 오프셋을 커밋하고, 새로운 파티션이 할당되어 있을 때 애플리케이션이 보유하고 있던 상태를 삭제해줌
5. 컨슈머는 재시도를 해야 할 수도 있다
    1. 레코드 #30 처리에 실패 → #31 처리에 성공한 경우, #31 오프셋을 커밋하면 #30 까지 처리 완료된 것으로 취급되어 버림
    2. 대응 방안
        1. #31 오프셋 커밋 후 별도 버퍼에 #30 저장, pause() 호출해서 추가적인 poll() 호출을 막아둔 후에 버퍼의 메시지를 처리한다
        2. 별도의 토픽에 #30 을 쓴 후 계속 진행한다. DLQ 토픽의 메시지를 읽는 컨슈머를 별도로 두거나 함께 처리하도록 한다 (DLQ 을 우선하도록 설정)
            1. dead letter queue 와 비슷한 시스템
6. 컨슈머가 상태를 유지해야 할 수도 있다
    1. 예를 들면 이동 평균을 계산하는 경우, 이전 값에 최신 값을 누적해서 결과를 계속해서 갱신해야 됨
    2. 컨슈머 프로세스가 재시작될 경우, 최신 메세지는 확인 가능하지만, 어떻게 누적된 값을 복구할 것인가?
    3. → 메시지를 읽어서 평균을 계산하고 `results` 와 같은 별도 토픽에 계속해서 쓴다 → 이 값을 다시 불러와서 갱신하고 다시 쓰기를 반복
        1. 카프카의 보장을 받을 수 있음

## 7.6 시스템 신뢰성 검증하기

- 이렇게 설정을 마친 뒤 검증도 해야한다!

### 7.6.1 설정 검증

1. 검증용 프로듀서, 컨슈머를 설정한다
2. 사용하고자 하는 설정을 적용한다
3. 아래와 같은 여러 시나리오를 구상한 후 테스트를 수행한다
    1. 리더 선출
        1. 리더를 정지시키면 어떻게 동작할까?
        2. 평상시처럼 작동을 재개하는데 얼마나 걸릴까?
    2. 컨트롤러 선출
        1. 컨트롤러가 재시작한 뒤 시스템이 재개되는 데 얼마나 걸릴까?
    3. 롤링 재시작
        1. 메시지 유실 없이 브로커들을 하나씩 재시작시킬 수 있을까?
    4. 언클린 리더 선출 테스트
        1. OSR 인 브로커를 리더로 사용하면 어떻게 될까?
        2. 용인할 수 있는 수준의 차이가 발생하는가?

### 7.6.2 애플리케이션 검증

- 다양한 상황에 대한 통합 테스트를 진행하자
    - 클라이언트가 브로커 중 하나와 연결이 끊어짐
    - 클라이언트와 브로커 사이의 긴 지연
    - 디스크 꽉 참
    - 디스크 멈춤
    - 리더 선출
    - 브로커 롤링 재시작
    - 컨슈머 롤링 재시작
    - 프로듀서 롤링 재시작

### 7.6.3 프로덕션 환경에서 신뢰성 모니터링

- 모니터링도 중요하다
- 프로듀서 JMX 지표
    - 레코드별 에러율
    - 재시도율
- 컨슈머 지표
    - 컨슈머 랙 (컨슈머가 브로커 내 파티션에 커밋된 가장 최신 메시지에서 얼마나 뒤떨어져 있는가)
- 브로커 관련
    - kafka.server:type=BrokerTopicMetrics,name=FailedProduceRequestsPerSec
    - kafka.server:type=BrokerTopicMetrics,name=FailedFetchRequestsPerSec
    - 예상되는 에러 응답 (브로커 교체 작업 진행 등) 을 뛰어넘는 에러 발생 시 확인해야 함
    - 요청 실패 지표에는 브로커가 보낸 에러 응답이 태그 형식으로 달려 있음
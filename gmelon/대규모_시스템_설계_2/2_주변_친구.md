# 1. 문제 및 설계 범위 확정

## 1.1 기능 정의 및 범위 설정

1. **주변 친구 정의:** 지리적으로 5마일(mile) 이내에 있는 친구로 정의하며, 이 수치는 설정 가능해야 함.
2. **거리 계산:** 두 사용자 사이의 직선거리로 가정함.
3. **사용자 규모 가정:** 10억 명의 사용자 중 10%인 1억 명이 이 기능을 활용한다고 가정함.
4. **동시 접속 사용자:** 일간 능동 사용자(DAU)의 10%인 천만 명이 동시에 시스템을 이용한다고 가정함.
5. **비활성 처리:** 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 주변 친구 목록에서 사라지도록 처리함.

## 1.2 기능 요구사항 (Functional Requirements)

1. 사용자는 모바일 앱에서 주변 친구 목록을 확인할 수 있어야 함.
2. 각 항목에는 해당 친구까지의 **거리**와 **갱신된 시각(timestamp)**이 함께 표시되어야 함.
3. 친구 목록은 **몇 초마다 한 번씩 갱신**되어야 함.

## 1.3 비기능 요구사항 (Non-functional Requirements)

1. **낮은 지연 시간 (Low Latency):** 위치 변화가 반영되는 데 오랜 시간이 걸리지 않아야 함.
2. **안정성:** 시스템은 전반적으로 안정적이어야 하며, 때로 몇 개 데이터가 유실되는 것은 용인할 수 있음.
3. **결과적 일관성 (Eventual Consistency):** 위치 데이터 저장에 강한 일관성을 요구하지 않으며, 데이터가 복제본과 동일하게 변경되는 데 몇 초 걸리는 것은 용인할 수 있음.

## 1.4 개략적 규모 추정

1. **주변 친구 정의:** 5마일(8km) 반경 이내 친구로 정의함.
2. **위치 갱신 주기:** 친구 위치 정보는 30초 주기로 갱신함.
3. **DAU:** 매일 주변 친구 기능을 활용하는 사용자는 1억 명으로 가정함.
4. **동시 접속 사용자:** 천만 명으로 가정함.
5. **평균 친구 수:** 사용자는 평균 400명의 친구를 가지며, 모두 이 기능을 활용한다고 가정함.
6. **위치 정보 갱신 QPS (Query Per Second):** 천만 명의 사용자가 30초마다 위치를 전송하면 초당 334,000번의 위치 정보 갱신 요청을 처리해야 함.

# 2. 개략적 설계안 제시 및 동의 구하기
## 2.1 개략적 설계안의 핵심 문제 및 구성 요소

1. **핵심 문제:** 활성 상태 친구의 새 위치 정보를 클라이언트에게 효과적으로 **전송(push)**하는 설계가 필요함.
2. **고부하 문제:** 천만 명의 동시 접속 환경에서 `초당 334,000번의 위치 갱신 요청`이 발생하며, 이로 인해 `초당 1400만(334,000 x 400 x 10%)건의 위치 정보 갱신 내역`을 사용자 단말로 보내야 하는 엄청난 양의 트래픽이 발생함.
3. **주요 컴포넌트:** 개략적 설계안은 **로드밸런서, 웹소켓** 서버 **클러스터, RESTful API** 서버, 레디스 **펍/섭**, 위치 정보 **캐시**, 사용자 **데이터베이스**, 위치 이동 이력 **데이터베이스**로 구성됨.

## 2.2 주요 컴포넌트 역할

![image.png](attachment:d90979e2-f13b-40b0-bbf6-623e44a5ceb9:image.png)

1. **로드밸런서:** 유상태(stateful) 웹소켓 서버와 무상태(stateless) RESTful API 서버 앞단에 위치하여 부하를 고르게 분산함.
2. **RESTful API 서버:** 사용자 추가/삭제, 정보 갱신 등 통상적인 요청/응답 처리를 담당하는 무상태 서버 클러스터임.
    
    ![image.png](attachment:1875492c-10ce-46f5-b3ae-e6d97ad77ac2:image.png)
    
3. **웹소켓 서버 (WS):** 친구 위치 정보 변경을 거의 실시간으로 처리하는 **유상태 서버 클러스터**임.
    - 각 클라이언트는 한 대의 웹소켓 서버와 지속적인 연결을 유지함.
    - 검색 반경 내 친구 위치가 변경되면 이 연결을 통해 클라이언트로 내역이 전송됨.
    - 초기화 시, 클라이언트의 모든 주변 친구 위치를 찾아 전송하는 역할도 함.
4. **레디스 위치 정보 캐시:** 활성 상태 사용자의 가장 최근 위치 정보를 캐시함.
    - 캐시 항목에는 **TTL(Time-To-Live)**이 설정되어, 기간이 지나면 사용자는 비활성 상태로 바뀌고 정보는 삭제됨.
5. **레디스 펍/섭 서버 (Pub/Sub):** 초경량 메시지 버스 역할을 하며, 새로운 채널 생성 비용이 아주 저렴함.
    
    ![image.png](attachment:464c601e-72df-49d8-947b-0060498663d6:image.png)
    
    - 특정 사용자의 위치 변경 이벤트는 해당 사용자에게 배정된 펍/섭 채널에 **발행(publish)**됨.
    - 해당 사용자의 친구와 연결된 웹소켓 연결 핸들러는 해당 채널의 **구독자(subscriber)**로 설정됨.
    - 위치 변경 이벤트 수신 시, 웹소켓 핸들러는 거리를 재계산하여 검색 반경 이내면 갱신된 위치와 시각을 클라이언트 앱으로 전송함.
6. **사용자 데이터베이스:** 사용자 데이터 및 친구 관계 정보를 저장함.
7. **위치 이동 이력 데이터베이스:** 사용자의 위치 변동 이력을 보관함 (주변 친구 기능과 직접 관계는 없음).

## 2.3 주기적 위치 갱신 흐름

![image.png](attachment:3783ab34-d90e-41fa-8826-07634abc0877:image.png)

1. **클라이언트 전송:** 모바일 클라이언트가 웹소켓 연결을 통해 위치 변경 내역을 로드밸런서에 전송함.
2. **WS 서버 수신:** 로드밸런서는 이를 웹소켓 서버로 보냄.
3. **이력 저장:** 웹소켓 서버는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장함 (병렬 수행).
4. **캐시 갱신:** 웹소켓 서버는 새 위치를 위치 정보 캐시에 보관하고 TTL을 갱신하며, 연결 핸들러 내 변수에도 반영함 (병렬 수행).
5. **펍/섭 발행:** 웹소켓 서버는 레디스 펍/섭 서버의 해당 사용자 채널에 새 위치를 발행함 (병렬 수행).
6. **구독자 브로드캐스트:** 발행된 위치 이벤트는 모든 구독자(온라인 상태 친구들의 웹소켓 핸들러)에게 브로드캐스트됨.
7. **거리 계산 및 전송:** 메시지를 받은 웹소켓 서버는 보낸 사용자와 수신 사용자 사이의 거리를 새로 계산함.
8. **결과 전송:** 계산된 거리가 검색 반경을 넘지 않으면, 새 위치 및 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송함.
9. **예제**
    
    ![image.png](attachment:aef56acd-fa82-4f12-badd-cbf8907e9515:image.png)
    

## 2.4 WS API 설계

| **종류** | **개요** | **요청** | **응답** |
| --- | --- | --- | --- |
| `서버 API` | 1. 주기적인 위치 정보 갱신 API | 위도, 경도, 시각 정보 전송 | 없음 |
| `클라이언트 API` | 2. 갱신된 친구 위치를 수신하는 API | 없음 | 친구 위치 데이터와 변경 시각 |
| `서버 API` | 3. 웹소켓 초기화 API | 위도, 경도, 시각 정보 전송 | 자기 친구들의 위치 데이터 수신 |
| `클라이언트 API` | 4. 새 친구 구독 API | 친구 ID 전송 | 가장 최근의 위도, 경도, 시각 정보 전송 |
| `클라이언트 API` | 5. 구독 해지 API | 친구 ID 전송 | 없음 |

## 2.5 데이터 모델

1. **위치 정보 캐시 (레디스)**
    - **목적:** '주변 친구' 기능을 활성화한 친구의 가장 최근 위치를 보관함.
    - **형태:** 키(사용자 ID) / 값({위도, 경도, 시각}) 쌍으로 보관함.
    - **특징:** 레디스는 읽기/쓰기 연산 속도가 빠르며, TTL을 지원하여 비활성 사용자 정보를 자동 제거함.
    - **영속성:** 위치 정보에 대해 영속성(durability)을 보장할 필요가 없으므로, 서버 장애 시 새 서버로 교체하고 캐시가 채워지기를 기다리면 됨.
2. **위치 이동 이력 데이터베이스**
    - **목적:** 사용자의 위치 변경 이력을 저장함.
    - **스키마:** latitude, longitude, timestamp, user_id를 따름.
    - **확장성:** 막대한 쓰기 부하를 감당하고 수평적 확장이 가능해야 하므로, **카산드라(Cassandra)**와 같은 NoSQL 데이터베이스가 적합함.
    - **샤딩:** 사용자 ID를 기준으로 샤딩하여 부하를 분산하고 운영 관리를 간편하게 함.

# 3. 상세 설계 및 확장성

> 개략적 설계안을 기반으로, 규모를 늘려나가며 병목 및 해결책을 찾는데 집중
> 

## 3.1 서버 클러스터 확장 전략

1. **RESTful API 서버 확장:** 무상태 서버이므로 CPU, I/O 상태에 따라 규모를 자동으로 늘리는 것이 일반적임.
2. **웹소켓 서버 클러스터 확장:** 유상태 서버이므로 제거 시 주의가 필요함.
    - **제거 절차:** 기존 서버를 제거하기 전에 로드밸런서가 해당 서버를 **'연결 종료 중(draining)'** 상태로 변경하여 새로운 연결을 막음.
    - 모든 연결이 종료된 후(또는 충분한 시간 경과 후) 서버를 제거함.
    - 유상태 서버 클러스터의 자동 확장을 위해서는 로드밸런서의 역할이 중요함.

## 3.2 클라이언트 초기화 및 구독

1. **클라이언트 연결:** 모바일 클라이언트는 기동 시 웹소켓 서버 클러스터 중 하나와 **지속성 연결**을 맺음.
2. **초기화 작업:** 연결 핸들러는 다음 작업을 수행함.
    1. 위치 정보 캐시의 해당 사용자 위치를 갱신하고, 연결 핸들러 내 변수에 저장함.
    2. 사용자 데이터베이스에서 모든 친구 정보를 가져옴.
    3. 위치 정보 캐시에 일괄 요청을 보내 친구들의 위치를 가져옴 (비활성 친구는 TTL로 인해 캐시에 없을 수 있음).
    4. 캐시가 반환한 친구 위치 각각에 대해 거리를 계산하여, 검색 반경 이내인 친구의 위치 정보를 클라이언트에 반환함.
    5. **각 친구의 레디스 펍/섭 채널을 구독**함.
3. **펍/섭 구독 전략:** 친구의 활성화/비활성화 상태에 관계없이 **모든 친구 채널을 구독**함.
    - 이는 설계의 복잡성을 줄이고, 친구가 활성화 상태로 전환될 때 별도의 구독 작업을 할 필요가 없게 함.
    - 비활성 친구 채널 구독에 필요한 메모리는 소량이며, CPU나 I/O 자원을 사용하지 않음.
4. **위치 전송:** 사용자의 현재 위치를 레디스 펍/섭 서버의 전용 채널을 통해 모든 친구에게 전송함.

## 3.3 사용자 데이터베이스 샤딩

1. **데이터 종류:** 사용자 상세 정보(프로파일)와 친구 관계 데이터가 보관됨.
2. **확장 필요성:** 설계 규모(10억 사용자)를 감안하면 단일 관계형 데이터베이스 서버로는 감당할 수 없음.
3. **샤딩:** 사용자 ID를 기준으로 샤딩하면 관계형 데이터베이스도 수평적 확장이 가능함.
4. **실제 운영:** 실제 대규모 시스템에서는 사용자 및 친구 데이터를 관리하는 별도의 API를 통해 데이터베이스를 간접적으로 이용해야 함.

## 3.4 위치 정보 캐시 확장 (레디스)

1. **메모리 용량:** 천만 명의 활성 사용자가 위치 정보(100바이트 가정)를 보관하는 데 필요한 메모리는 1GB 수준으로, 최신 레디스 서버 한 대로 충분함.
2. **갱신 부하:** 다만 초당 `334K에 달하는 갱신 연산`은 최신 고사양 서버에도 부담이 될 수 있음.
3. **샤딩:** 각 사용자의 위치 정보는 독립적이므로, 사용자 ID를 기준으로 여러 서버에 샤딩하여 부하를 고르게 분배함.
4. **가용성:** 각 샤드에 **대기(standby) 노드**를 복제해 두어, 주(primary) 노드 장애 시 신속하게 승격시켜 장애 시간을 줄임.

## 3.5 레디스 펍/섭 서버 클러스터 확장

1. **펍/섭 선택 이유:** 채널을 만드는 비용이 저렴하며, 구독자가 없는 채널로 전송된 메시지는 버려지므로 서버 부하가 거의 없음.
2. **채널 할당 전략:** '주변 친구' 기능을 활용하는 **모든 사용자에게 채널 하나씩을 부여**함.
3. **메모리 사용량 추정:** 1억 명의 활성 사용자(10% 가정)와 친구 100명당 20바이트의 포인터가 필요하다고 가정하면, 총 200GB 의 메모리가 필요함.
    - 100GB 메모리를 가진 최신 레디스 서버 두 대면 채널 보관이 가능함.
4. **CPU 사용량 (병목):** `초당 1400만 건의 위치 업데이트 메시지를 전송`해야 하므로, 서버 한 대로 처리하기는 곤란함.
    - 보수적으로 서버 한 대가 100,000명의 구독자를 감당한다고 가정하면, 필요한 레디스 서버의 수는 140대 임.
5. **결론:** 레디스 펍/섭 서버의 병목은 메모리가 아니라 **CPU 사용량**이며, 이 규모를 감당하려면 **분산 레디스 펍/섭 클러스터**가 필요함.

## 3.6 분산 레디스 펍/섭 서버 클러스터

1. **샤딩 기준:** 모든 채널은 서로 독립적이므로, 메시지를 발행할 사용자 ID를 기준으로 펍/섭 서버들을 샤딩함.
2. **안정 해시 (Consistent Hashing) 도입:** 수백 대의 서버 운영 및 장애 처리를 위해 **서비스 탐색(service discovery) 컴포넌트**를 도입하고 **안정 해시**를 사용함.
    
    ![image.png](attachment:bb2582e9-79f8-49ad-8216-61b005b2c9a4:image.png)
    
    - **서비스 탐색 역할:** 가용한 서버 목록을 유지하고 갱신하며, 해시 링 정보를 키-값 쌍으로 저장함 (예: 주키퍼, etcd).
    - **해시 링:** 활성 상태의 모든 펍/섭 서버로 구성된 해시 링을 보관함.
    - **채널 선정:** 웹소켓 서버는 메시지를 발행하거나 구독할 채널을 정할 때 이 해시 링을 참조함.
3. **메시지 발행 과정:**
    
    ![image.png](attachment:5c3b1ebe-0cb2-428a-a919-290d2543ed7f:image.png)
    
    1. 웹소켓 서버는 해시 링을 참조하여 메시지를 발행할 펍/섭 서버를 선정함.
        - *성능 효율을 위해 해시 링 사본을 웹소켓 서버에 캐시할 수 있으며, 이 경우 원본과의 상태 동기화를 유지해야 함.*
    2. 선정된 펍/섭 서버는 해당 사용자 채널에 위치 정보 변경 내역을 발행함.

## 3.7 클러스터 확장 고려사항 (유상태 서버)

1. **펍/섭 서버의 상태:** 펍/섭 채널을 통해 처리되는 데이터 자체는 무상태이나, 각 채널의 구독자 목록을 보관하므로 **펍/섭 서버는 유상태 서버**로 취급해야 함.
2. **확장/축소의 위험성:** 유상태 서버 클러스터의 규모를 조정하는 것은 운영 부담과 위험이 크므로 주의 깊게 진행해야 함.
    1. 일반적으로 오버 프로비저닝 수행
3. **확장 시 문제점:**
    1. 클러스터 크기 조정 시 해시 링이 갱신되어 많은 채널이 다른 서버로 이동함.
    2. 서비스 탐색 컴포넌트가 웹소켓 서버에 갱신을 알리면 **엄청난 재구독(resubscription) 요청**이 발생함.
    3. 재구독 요청 처리 중 클라이언트가 보내는 위치 변경 메시지 처리가 누락될 수 있음 (손실은 허용되나 최소화해야 함).
4. **확장 시점:** 클러스터 크기 조정은 시스템 부하가 가장 **낮은 시간대**를 골라서 시행해야 함.

## 3.8 운영 고려사항 (서버 교체)

1. **서버 교체:** 서버 장애는 일상적으로 발생하며, 클러스터 크기 조정 때보다 채널의 대규모 이동 사태를 초래할 가능성이 낮음.
2. **장애 처리 절차:**
    1. 모니터링 소프트웨어가 펍/섭 서버 장애를 감지하고 온콜 엔지니어에게 경보를 발송함.
    2. 담당자는 서비스 탐색 컴포넌트의 해시 링 키 값을 갱신하여 장애 서버를 대기 중인 교체 노드로 바꿈.
    3. 이 사실이 모든 웹소켓 서버에 통지되고, 각 웹소켓 서버는 연결 핸들러에게 새 서버의 채널을 다시 구독하도록 알림.
    4. 각 연결 핸들러는 구독 중인 채널 목록을 해시 링과 대조하여 새 서버로 구독 관계를 다시 설정해야 하는지 검토함.
    
    ![image.png](attachment:2712afde-2f96-42c2-81b3-79fd24d33a76:image.png)


## 3.9 친구 추가/삭제 및 친구가 많은 사용자 처리

1. **친구 추가/삭제 처리:**
    - 친구 추가/삭제 시 해당 앱에 등록된 **콜백**이 호출됨.
    - 이 콜백은 웹소켓 서버로 새 친구의 채널을 **구독**하거나, 삭제된 친구의 채널 **구독을 취소**하라는 메시지를 보냄.
    - 웹소켓 서버는 구독 메시지 처리 시 해당 친구가 활성화 상태인 경우 가장 최근 위치 정보를 응답으로 보냄.
2. **친구가 많은 사용자:**
    - 친구 수 상한(예: 5,000명)이 있다고 가정함.
    - 수천 명의 친구를 구독하는 펍/섭 구독 관계는 클러스터 내 여러 웹소켓 서버에 분산됨.
    - 따라서 위치가 변경되는 데 따른 부하는 각 웹소켓 서버가 나누어 처리하므로 **핫스팟(hotspot) 문제는 발생하지 않을 것**으로 예상됨.
    - 다만, 친구가 많은 사용자의 채널이 존재하는 펍/섭 서버는 부하가 증가할 수 있으나, 100대가 넘는 서버에 채널이 분산되므로 특정 서버에 막대한 부담을 주지는 않을 것으로 예상됨.

## 3.10 주변의 임의 사용자 기능 (보너스 점수)

1. **기존 설계 훼손 없는 지원 방안:** **지오해시(GeoHash)**에 따라 구축된 별도의 펍/섭 풀을 두는 것임.
2. **지오해시 기반 채널:** 지도를 격자로 나누고, **격자마다 채널을 하나씩** 만들어 둠.
3. **구독 전략:** 모든 사용자는 자신이 위치한 격자에 할당된 채널을 구독함.
4. **위치 변경 전송:**
    1. 사용자 위치가 변경되면 웹소켓 연결 핸들러는 지오해시 ID를 계산하고, 해당 ID를 담당하는 채널에 새 위치를 전송함.
    2. 근방의 사용자들은 해당 채널을 구독하고 있으므로 위치 변경 메시지를 수신함.
5. **경계 처리:** 격자 경계에 있는 사용자를 처리하기 위해, 클라이언트는 자신의 지오해시뿐 아니라 **주변 모든 지오해시 격자(총 아홉 개 격자)**를 담당하는 채널도 구독함.

## 3.11 레디스 펍/섭 외의 대안: 얼랭 (Erlang)

1. **얼랭의 장점:** 얼랭은 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경임.
    - **경량 프로세스:** 얼랭 프로세스 생성 비용이 리눅스 프로세스에 비해 엄청나게 저렴하며, 가장 작은 프로세스는 300바이트의 메모리만을 사용함.
    - 최신 서버 한 대로 수백만 프로세스를 실행할 수 있으며, 아무 일도 하지 않는 프로세스는 CPU 자원을 소모하지 않음.
    - **모델링:** 천만 명의 활성 사용자 각각을 얼랭 프로세스로 모델링할 수 있으며 비용이 저렴함.
    - **분산 용이성:** 여러 서버로 분산하기 쉽고, 운영 부담이 낮으며, 실시간 디버깅 도구를 갖추고 있음.
2. **얼랭 활용 방안:**
    - 웹소켓 서버 클러스터를 얼랭으로 구현하고, 레디스 펍/섭을 **분산 얼랭 애플리케이션**으로 대체할 수 있음.
    - 각 사용자는 얼랭 프로세스로 표현되며, 이 프로세스는 웹소켓 서버를 통해 위치를 수신함.
    - 친구 관계에 있는 사용자 프로세스와 구독 관계를 설정하고 위치 변경 내역을 수신함.
    - 얼랭/OTP는 구독 기능을 내장하고 있어 구현이 쉬우며, 프로세스 간 연결망(mesh)을 통해 위치 변경이 친구들에게 효과적으로 전파됨.
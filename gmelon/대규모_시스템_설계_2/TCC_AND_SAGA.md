# TCC 패턴의 한계와 Saga 패턴의 해결책

## TCC (Try-Confirm/Cancel) 패턴이란?

분산 트랜잭션을 처리하기 위한 2단계 패턴.

| 단계 | 설명 |
|------|------|
| **Try** | 리소스 예약 (실제 커밋 X, 임시 상태로 잠금) |
| **Confirm** | 모든 Try 성공 시 → 최종 커밋 |
| **Cancel** | 하나라도 실패 시 → 예약 해제 |

```
주문 → [Try 재고예약] → [Try 결제예약] → [Try 배송예약]
                    ↓ 모두 성공
       [Confirm 재고] → [Confirm 결제] → [Confirm 배송]
```

---

## TCC의 단점

### 1. 동기식 블로킹 처리
모든 서비스가 Try 단계를 완료할 때까지 **대기 필수**. 한 서비스가 느리면 전체가 느려짐.

### 2. 리소스 장기 잠금
Try 단계에서 리소스를 예약(Lock)하고 Confirm/Cancel까지 유지 → 동시성 저하, 데드락 위험.

### 3. 높은 구현 복잡도
각 서비스가 Try/Confirm/Cancel 3가지 API를 모두 구현해야 하며, 중간 상태(예약 상태) 관리 로직 필요.

### 4. 강한 결합
오케스트레이터가 모든 참여 서비스를 알고 동기적으로 호출 → 서비스 간 결합도 높음.

---